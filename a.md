[]{#_Hlk519102085 .anchor}区块链数据库系统实现

序言

随着你不断的深入学习区块链知识，终有一天你会想要自己从零开始实现一个完整的区块链程序。这样做不但可以把以前学习的各种零散的区块链知识有机的结合在一起了，也通过对底层的了解，你终于可以用区块链实现你想要做的事情了，而不仅仅是现在已经成熟应用的几个有限的领域。

在我第一次从零开始写区块链程序的时候，我有一个明确的愿景，想要做一个区块链数据库，用以轻松的替代现存的关系型数据库，虽然开源的区块链程序不计其数，但受限于我当时对区块链底层技术的理解，在开源区块链的基础上修改出我所期望的区块链数据库，这个目标并不现实，因为显然这些开源区块链程序并没有为我做这样的扩展做好铺垫，于是我从零开始，一个模块一个模块的将区块链领域的各个知识点打通了，并知道和克服了一系列的底层的诸如性能优化、设计抉择的困难，最终实现了最初的愿景——区块链数据库。

这不是终点，就如大家所知的，关系型数据库利用“关系”，ACID原则等使得数据库程序更加的健壮和稳定，但却牺牲了性能，总有一些行业和应用更加关心数据库的性能，于是NoSql数据库应运而生，在这些“简单”的数据库中，所有维持系统健壮和稳定的事情都需要程序员亲力亲为，但系统却提供了前所未有的高性能。而在这个过程中开发的区块链数据库虽然提供了一种快捷、方便，且稳定、健壮的选择，但却牺牲了性能，当前区块链行业发展迅速，会有各行各业拥有不同的对数据库的要求，这并不是一个全能型方案。

因此本书里详细的带领大家通过亲自编写一个类比特币的区块链程序，再编写一个类以太坊的区块链程序，最终结合这个过程中学到的经验，编写了一个区块链数据库程序，以此让读者朋友们了解到编写区块链程序的过程，以及这个过程中涉及到的问题和挑战，为未来读者朋友自己实现符合自己业务需求的区块链数据库奠定基础。

本书没有使用学术界推崇的伪代码方式，而是直接使用C\#（符合DotNet Core
2.0框架的）编写的代码，代码不但可以直接在实际项目中应用，学习过程还可以通过真实代码的实际执行，并结合章节习题亲自动手修改代码，加深对区块链理论的认识，并可以将这些能力更快的应用到实际项目中去。

第一部分 古典的区块链
=====================

比特币作为第一个实践区块链的程序，被称作第一代区块链、区块链1.0或古典区块链。在第一部分中，本书将带领你从零开始实现一个类似于比特币的区块链程序。

初探区块链
----------

### 比特币的历史及发展

区块链的历史，其实就是比特币的历史。

#### 比特币的发布到壮大

2008年10月31日，一份署名中本聪的论文被发表在bitcoin.org网站上（该域名于两月前才被注册），其标题为《比特币：一种点对点的电子现金系统》。论文中详细描述了如何使用对等网络来创造一种“不需依赖信任第三方的电子交易系统”，而正是在这篇论文当中他提出了区块链这样一种数据结构。

2009年1月3日比特币网络上线，推出了第一个开源的比特币客户端软件，中本聪使用该软件对挖出了创世区块（第一个区块），并获得了第一笔的50个比特币。在这笔交易中包含了这样的一句话“The
Times 03/Jan/2009 Chancellor on brink of second bailout for
banks”，这是当天的泰晤士报头版标题，也是对当时由银行系统引起的不稳定的一种嘲讽。

2010年5月，佛罗里达的一个程序员，用1万比特币购买了价值25美元的披萨优惠券（2个披萨），而当时的比特币价格纯粹是根据比特币论坛上的使用者彼此协商的结果。

2010年11月27日，世界上最早的矿池出现了。在当时看来，建立矿池是一件很有远见的事情。以当年1万比特币才能兑换25美元的披萨优惠券来说，比特币总量2100万，也就价值5万多美元，这对于当时的矿池来说，其实是没有足够的经济利益的。

2011年，后来成为以太坊之父的维塔利克（Vitalik），协同创办了《比特币杂志》。

2012年10月，BitPay发布报告说，全球超过1000家商户通过他们的支付系统来接收比特币的付款。

2013年10月，世界第一台比特币柜员机在加拿大温哥华问世，由Robocoin公司所推出，允许使用者把比特币兑换成为加元提取，每天最高上限为3千加元；另一方面，使用者亦可以透过存入现金购入比特币

2013年12月，中国人民银行发布了《关于防范比特币风险的通知》，明确了比特币不具有，与法币等同的法律地位。

随着比特币的不断发展，比特币越来越被大众所接受，比特币网络的算力也是突飞猛进，在Github上面与比特币相关的项目数也是大幅的增长。

#### 站在巨人肩膀上

比特币的各项技术基础也在比特币之前一步一步的成型了。

1979年，拉尔夫·默克尔（Ralph Merkle）将其提出的默克尔树申请了专利。

1982年，大卫·乔姆（David Chaum）最早提出了不可追踪的密码学网络支付系统。

1985年，Neal Koblitz和Victor S.
Miller独立提出了椭圆曲线加密算法（ECC），该算法在2004年到2005年开始大范围的使用。

1990年，乔姆将他的想法扩展为最初的密码学匿名现金系统，这个系统就是后来所谓的ecash。

1998年，戴维（Wei
Dai）发表文章阐述一种匿名的、分布式的电子现金系统，他将其命名为“b-money”。同一时期，尼克·萨博发明了“Bit
gold”。和比特币一样，“Bit
gold”也设置类似的机制，用户通过竞争性地解决“工作量证明问题”，然后将解答的结果用加密算法串联在一起公开发布，构建出一个产权认证系统。“Bit
gold”的一个变种是“可重复利用的工作量证明”，开发者是哈尔·芬尼（比特币中第一笔转账交易的接收者）。

1999年，P2P文件共享软件Napster上线，使得P2P网络共享这种非常专业的事情走入普通人的世界。

2001年，美国国家标准与技术研究院（NIST）发布了SHA-2，并申请了专利，但同时也授权公众可以无版税的使用该算法。

#### 比特币历史上的失误

2010年8月6日，比特币协议被发现重大漏洞，交易在登录到区块链之前并没有经过完整认证，让使用者可以绕过比特币的经济限制设定，并制造出无上限的比特币。8月15日，这个漏洞被恶意利用，一笔转账交易过程中产生了1840亿比特币，并分别转送到比特币网络上的两个地址。数小时内，这笔异常交易就被发现，并在漏洞修复后这笔异常交易被识别为无效交易，整个网络也更新为新版的比特币协议，网络发生软分叉。截至2018年7月，这是比特币历史上唯一发现并被利用的重大安全漏洞。

2013年3月12日，比特币迎来了重大的0.8版本，该版本会产生超过0.7版本允许大小的区块（由于开发者没有注意到原作者中本聪写的区块大小限制，这也是后来非常重大的功能“隔离见证”试图解决的问题），导致比特币网络出现明显的分叉，对于用户能感知到的，是可以在运行0.7和0.8版本的交易所（即两个分叉）上分别花掉一次同一份钱。作为反馈，Mt.
Gox交易所临时停止了比特币的提现，比特币价格也迅速的下跌。当时的主要矿工讨论决定将新版本退回到旧版本0.7，使得0.8版本导致的分叉被废弃掉，几个小时后，整个比特币网络重新恢复了共识。

### 区块链系统概述

狭义来讲，区块链是一种按照时间顺序将数据区块以顺序相连的方式组合成的一种链式数据结构，
并以密码学方式保证的不可篡改和不可伪造的分布式账本。

广义来讲，区块链技术是利用块链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学的方式保证数据传输和访问的安全、利用由自动化脚本代码组成的智能合约来编程和操作数据的一种全新的分布式基础架构与计算方式。

以下几节分别从密码学、区块链的链状结构、分布式网络、轻量客户端和智能合约方面对区块链系统做概念上的阐述。

本章内容并没有打算深入到每一个细节，只是希望能给读者以区块链的全局观，方便后续做程序实现的时候，可以更加明白自己正在做的是区块链的哪个部分，而技术细节和一些关于细节方面的疑问都会在后续的具体代码实现的章节中得到解答。

#### 用密码学保护区块

##### 哈希计算

密码学上的哈希算法一般需要具有以下的性质：

-   函数的输入可以是任意长的字符串；

-   函数的输出是固定长度的；

-   函数的计算过程应该是高效的。

哈希计算，即通过一个算法将任意一段输入字符串计算出一个固定长度的数值。通过哈希算法计算出的结果，是无法再通过任何算法还原出原始数据的。即哈希计算是单向的，因此可以用于判断数据的完整性，哪怕再小的一点数据变化，都会导致重新计算的哈希结果与之前的结果会大不一样。

如下图所示，无论原始内容改动是多么的小，或者变化多么的大，其通过哈希函数后的输出都会非常的不一样。

![](media/image1.png){width="2.337423447069116in"
height="1.4936253280839895in"}

由于哈希算法的输出值是固定长度的，而原始数据的长度却是任意，在理论上存在不同的原始数据对应同一哈希值的可能，如下图所示情况。

![](media/image2.png){width="2.8718985126859145in"
height="2.2024540682414697in"}

这种情况在原始数据的数量极其庞大的时候就会出现。然而由于哈希计算的抗冲突性，即找到有冲突的两个输入的代价非常大，所以人为的想要持续找到两个冲突的哈希值的可能性接近于零。

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  扩展知识
  
  密码学中常用的哈希算法有MD5、SHA1、SHA2、SHA256、SHA512、SHA3、RIPEMD160，下面简单介绍一下。
  
  -   MD5（Message Digest Algorithm5）。MD5是输入不定长度信息，输出固定长度128bits的算法。经过程序流程，生成4个32位数据，最后联合起来成为一个128bits哈希。基本方式为求余、取余、调整长度、与链接变量进行循环运算，得出结果。MD5算法曾被广泛使用，然而目前该算法已被证明是一种不安全的算法。
  
  -   SHA1（Secure Hash Algorithm 1）。SHA1在许多安全协议中广为使用，包括TLS和SSL。2017年2月，Google宣布已攻破了SHA1，并准备在其Chrome浏览器产品中逐渐降低SHA1证书的安全指数，逐步停止对使用SHA1哈希算法证书的支持。
  
  -   SHA2。这是SHA算法家族的第二代，支持了更长的摘要信息输出，主要有SHA224、SHA256、SHA384和SHA512，数字后缀表示它们生成的哈希摘要结果长度。SHA256在比特币中扮演了非常重要的角色，它既是挖矿的主要算法，也是比特币地址创建中必要算法。
  
  -   SHA3。这是SHA算法家族的第三代，之前名为Keccak算法，SHA3并不是要取代SHA2，因为目前SHA2并没有出现明显的弱点。需要注意的是，以太坊使用的Keccak-256，在部分文档中也写作SHA3，与美国国家标准与技术研究院（NIST）发布的SHA3-256标准是不一样的。
  
  -   RIPEMD-160（RACE Integrity Primitives Evaluation Message Digest160）RIPEMD160是一个160位加密哈希函数。它旨在替代128位哈希函数MD4、MD5和RIPEMD-128。RIPEMD160在比特币中用来生成比特币地址，相比使用SHA256来说，可以使得地址在保证不重复的基础上更加简短。
  
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

##### 数字签名

我们从一个故事讲起，Alice想要发送消息给Bob，但是通讯通道并不安全，Eve在通讯通道中将消息截获并将Alice发送的内容修改后发送给Bob。如下图，Alice原本想要将“8”这个消息发送给Bob，但是Eve在通讯通道中悄悄的把“8”改成了“9”，并告诉Bob这个消息就是Alice发送给他的。

![](media/image3.png){width="5.801388888888889in"
height="1.197917760279965in"}

我们现在需要一种机制，使得Bob可以确认他所收到的消息确实是Alice所想要传达的，并明确这个消息并没有被任何人修改过，这种机制就是数字签名机制。

以下我们用一些非常简单的数字来做数字签名的演算，读者朋友们可以亲自动手计算起来，计算过程中只会用到乘法运算、幂运算（乘积运算）和取余运算而已，但是因为有幂运算，即便数字已经非常小了，你应该需要一个计算器。

此处将步骤列为表格形式：

  -------------------------------------------------------------------------------------------------------
  步骤                                   只有Alice知道的信息            所有人都知道的信息
  -------------------------------------- ------------------------------ ---------------------------------
  选取一个素数                           d=11                           

  选取两个不是2的素数                    p=3, q=5                       

  计算pq的乘积，并公开结果               n=pq=15                        n=15

  选择小于n的整数e，并公开                                              e=3

  准备发送的消息                                                        m=8

  对发送的消息签名，并公开               $$s = m^{d}\text{\ mod\ n}$$   s=2
                                                                        
                                         $$= 8^{11}\ mod\ 15 = 2$$      

  接收者根据已知信息进行验算，确认签名                                  $$s^{e} \equiv m\ mod\ n$$
                                                                        
                                                                        $$2^{3} = 8 \equiv 8\ mod\ 15$$
  -------------------------------------------------------------------------------------------------------

以上表格中“只有Alice知道的信息”列中的信息及计算过程，是只有Alice才知道的，不应该被泄漏的，一旦泄漏了，那整个签名的可靠性便无从谈起了；而“所有人都知道的信息”列中的信息及计算过程，可以被Bob或者Eve知道，而对于Eve即便知道了这些信息，但是如果没有得到仅有Alice知道的信息d，Eve也是无法方便的篡改和伪造信息的。

以上整体过程如下图所示：

![](media/image3.png){width="5.801388888888889in"
height="2.0104166666666665in"}

在本例中，私钥即只有Alice知道的d，而公钥就是公开的n。

如果Eve试图篡改信息“8”为“9”，会使得$2^{3} = 8 \neq \ 9\ mod\ 15$，等式不成立，即说明信息被修改了，为此，Eve必须试图一同篡改签名s，于是Eve必须做以下一系列的运算：

$$1^{3}\ \text{mod}\ 15 = 1 \neq 9$$

$$2^{3}\ mod\ 15 = 8 \neq 9$$

$$3^{3}\ mod\ 15 = 12 \neq 9$$

……

$$8^{3}\ mod\ 15 = 2 \neq 9$$

$$9^{3}\ mod\ 15 = 9$$

Eve总共做了9次运算才找到一个有效的签名，以此来篡改和伪造数据，在本例中我们使用了非常小的数字，所以Eve才能在相对较短的时间完成篡改和伪造数据，但如果我们使用以下稍微大一点的数字呢？

假设d=29, p=7, q=13,n=pq=91, e=5，

当m=8时，

$$s = m^{d}\ mod\ n = 8^{29}\text{\ mod\ }91 = 8$$

做验证的时候只需要做：

$$s^{e} \equiv m\ mod\ n$$

$$8^{5} = 8 \equiv 8\ mod\ 91$$

便可以轻松的通过签名验证信息，但如果Eve试图伪造，不得不做以下一系列的艰难运算：

$$1^{5}\ \text{mod}\ 91 = 1 \neq 9$$

$$2^{5}\ mod\ 91 = 2 \neq 9$$

……

$$81^{5}\ mod\ 91 = 9$$

而随着我们选取的数字越大，Eve在有限时间内可以伪造的可能性就越小。

注意1：该签名过程是为了帮助读者在短时间内理解数字签名的基本原理和特性，故在很多方面都做了简化处理，若使用以上步骤在实际生产环境中会出现致命的漏洞，故有兴趣深入研究的读者应该继续学习RSA密码体系，本书不在这方面深入了；

注意2：本例旨在帮助读者快速理解数字签名的不可逆和不易伪造的原理和特点，并没有暗指比特币或者区块链应该或使用了该例中的原理过程，实际上有相当多一部分的区块链均选择了椭圆曲线加密体系，本节也并不在这方面深入，在后续章节中，实现区块链的非对称加密算法时会详细讲解；

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  扩展知识
  
  为什么是Alice和Bob？
  
  RSA密码体系的三位作者Rivest、Shamir、Adleman，在其于1978年2月发表的论文《一种实现数字签名和公钥密码系统的方法》（A Method of Obtaining Digital Signatures and Public-Key Cryptosystems）中首次使用了Alice和Bob，在此之前，通信领域论文中一般用A表示数据发送方，用B表示数据接收方。使用Alice和Bob后，一方面不但避免使用普通的字母A和B，而且这两个名字的英文首字母仍维持A和B不变；另一方面是因为Alice和Bob分别为女性名字和男性名字，这样在论文后面的部分中就可以使用英语的她和他分别指代Alice和Bob，让论文更加清晰。
  
  为什么是Eve？
  
  后来人按照Alice和Bob的命名规则，用单词窃听者（Eavesdrop，/ˈiːvzdrɒp/）的读音第一个音节选出了一个常用名字。
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

##### 对交易签名

要想发起一笔交易，我们需要按以下步骤：

-   准备交易的详情内容，包含从哪里转账到哪里，以及转账多少的信息；

-   将这些详情打包并使用哈希计算方法，计算出该交易详情的哈希值；

-   使用仅有发起该笔交易的用户拥有的私钥对该哈希值进行签名；

-   将交易详情、交易哈希和交易签名打包在一起成为一笔交易包；

-   将这个交易包发送到区块链网络；

以上步骤形成的示意图如下：

![](media/image15.png){width="6.510417760279965in"
height="2.5520833333333335in"}

#### 把区块连成链状

区块链是由许多区块按照时间顺序链接而成的，而每个区块中则存储有交易数据。我们可以这样理解，区块就是交易账本当中的每一页，而每页上面记录了所有交易的变更情况。所有交易都会放入交易池，而矿工负责选出适量的交易并打包成区块，最终添加到现有区块链的末尾。鉴于区块链上早先的区块会由于链条的变成而变得在链条上越来越深，因此会变得越来越难以修改。也正因如此，使得区块链具有很高的防篡改性。

##### 用哈希标记区块

区块中包含许多交易，而将包含所有交易在内的内容统一计算出哈希值，鉴于哈希值的抗冲突特性，任何一个哈希值便可以代表整个区块，对于两个相同哈希值的区块，即便我们不用对比里面每一个字段，我们也可以信心满满的认为他们区块中的每个字段是相同的。

比较特别的，在比特币网络中会要求这个哈希值的数值小于指定的难度系数，直观的感觉便是在该哈希值的十六进制表示中的前面一定位数的字符为0时，才是有效的哈希值，即该区块有效，可以被视为区块链中的一个区块。这个便是比特币中的工作量证明，因为寻找符合这样的要求的哈希值是非常困难的，而无法取巧的，必须通过一定的工作量才能完成的。

  ---------------------------------------------------
  版本             1
  ---------------- ----------------------------------
  前一区块哈希值   00000000000000000016bd6a04efb06d
                   
                   2a1a1bf1c5a42b3da0b4f1e6f48a1a1f

  默克尔树根       1e2790419058e27b6e680d6f230a44bf
                   
                   153885fe41fd00c9156475b49a488a0a

  时间戳           1531353835

  难度系数         5,363,678,461,481.36

  随机数           224885659

  交易数量         133

  CoinBase交易

  其他交易
  ---------------------------------------------------

如上表，就是一个典型的区块的样子，所有深色部分的字段汇总在一起计算出了本区块的哈希值，而该哈希值是几乎不可能通过伪造另外一个区块来获取的，故该哈希值便可以完全代表这个区块。

##### 单向链表的区块链

如下图，将前一区块的哈希值记录在区块的头部，使得区块之间形成链状，也是因此使得前一区块的任意修改，会导致后续链接的所有区块的哈希值的变化，使得原区块链断链，这会导致由于有计算量的存在，使得修改较早区块后变短的区块链在共识（共识将在后续章节中详细讲解）中失去竞争优势，最终不被区块链网络所认可而被抛弃，这也是区块链之所以成为链状结果，并能够防篡改的核心所在。

区块通过前一区块哈希值的方式形成的是单向链表，即我们无法通过一个较早的区块了解到哪一个区块是链接在他后面的。实际情况，正是由于单向链表的特性，才会出现分叉的情况，即有多个区块链接到同一个前一区块。

#### 用分布式网络把区块共享出去

分布式网络是由分布在不同地点的计算机系统互连而成，网中无中心节点。网中任一点均至少与两条线路相连，当任意一条线路发生故障时，通信可转经其他链路完成，具有较高的可靠性。同时，分布式网络还具有易于扩展的特点。

点对点网络（peer-to-peer，
简称P2P），又称对等式网络，是分布式网络的一种具体应用，是无中心服务器、依靠用户群交换信息的互联网体系，它的作用在于，减低以往网路传输中的节点，以降低数据遗失的风险。与有中心服务器的中央网络系统不同，对等网络的每个用户端既是一个节点，也有服务器的功能，任何一个节点无法直接找到其他节点，必须依靠其户群进行信息交流。

比特币的区块链网络便是点对点网络，也即分布式网络。以下我通过一个示例来说明新区块在区块链网络中的传播和更新机制。

如下图，区块链网络正好处于一个时间节点，其所有节点的区块链拥有完全相同的数据，即区块链的末尾为白色五星区块。

![图片包含 天空, 悬挂, 电线
已生成极高可信度的说明](media/image26.png){width="2.6964337270341208in"
height="2.2916666666666665in"}

如下图左，随着时间推移，位于左侧的节点X和位于右侧的节点Y在同一时间成功的产生了新的区块，但左侧节点X产生了白色三角形的新区块，而右侧节点Y则产生了橙色倒三角形，并同时开始向与其连接的其他节点广播其新区块。

网络传播需要时间，但是一段时间过后，会出现如下图右所示，所有节点上的纯区块链数据又是相同的了——通过一个分叉将两个节点产生的区块均临时的包含在区块链上，所有节点均会以最先收到的那个分叉区块作为当前节点的区块链尾部区块，并以此尾部区块，去试图通过工作量证明的方式延伸这一条分支。

  --------------------------------------------------------------------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------
  ![图片包含 天空 已生成高可信度的说明](media/image27.png){width="2.9010411198600177in" height="3.753020559930009in"}   ![图片包含 文字, 天空, 地图, 浅色 已生成极高可信度的说明](media/image28.png){width="2.8175207786526686in" height="3.3802088801399823in"}
  --------------------------------------------------------------------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------

如下图左，随着时间推移，其中某一个节点在优先收到的尾部节点的基础上进行计算，并成功的计算出了一个新的区块，随即它便向它周围的节点进行广播它的成果，凡是接收到它的新区块的节点，都会因为它广播的这个区块使得这个分支比其他分支更长，而将尾部区块更新到这个分支上来。

如下图右，随着区块信息在区块链网络中的传播，很快便使得整个区块链网络回到了所有节点均为同样数据的状态。

  ----------------------------------------------------------------------------------------------------------------------------- ----------------------------------------------------------------------------------
  ![图片包含 文字, 地图 已生成极高可信度的说明](media/image29.png){width="2.9114588801399823in" height="4.184433508311461in"}   ![](media/image30.png){width="2.840444006999125in" height="4.082368766404199in"}
  ----------------------------------------------------------------------------------------------------------------------------- ----------------------------------------------------------------------------------

以上过程演示了区块生成并在分布式网络中传播，并通过简单的机制选择区块分支的全过程，在比特币网络中，这样的事情可以说随时都在发生。

#### 保存少量数据的轻量客户端

并非所有的节点都有能力储存完整的区块链。许多比特币客户端被设计成运行在空间和功率受限的设备上，如智能手机、平板电脑、嵌入式系统等。对于这样的设备，通过简化的支付验证(SPV)的方式可以使它们在不必存储完整区块链的情况下进行工作。这种类型的客户端被称为SPV客户端或轻量客户端。随着比特币的使用热潮，轻量客户端逐渐变成比特币节点（尤其是比特币钱包）所采用的最常见的形式。

轻量客户端仅仅需要下载区块头信息，而不用下载包含在每个区块中的交易信息。由此产生的不含交易信息的区块链，大小会远远小于完整的区块链，这样便适合在受限环境上执行。鉴于轻量客户端并不知道网络上所有交易的完整信息，其验证交易时所使用的方法略有不同，这个方法需依赖对等的全节点“按需"提供区块链中相关部分的局部视图。

举例子来说，每个全节点就像是一个带着非常详尽、涵盖街道地区的完整地图的游客，因此它可以随时通过翻阅地图，了解到它所想知道的信息。而轻量客户端就像是带着手机的游客，它只知道它的目的地名字，它需要通过手机从另外拥有完整地图的陌生游客那里获取它的行进路线。

虽然两种游客都可以通过实地考察的方式来验证一条街是否存在，但没有完整地图的游客不知道每个小巷中有哪些街道，也不知道附近还有什么其他街道。对他来说，最好的方式就是向足够多的人问路，并且希望其中一部分人不是要试图抢劫他。

轻量客户端中配备的SPV功能可以用来验证其询问的完整区块链节点是否在欺骗它。根据轻量客户端的询问请求内容，一个拥有完整区块链的节点会构造一条验证链，这条链是由沿着区块链按时间倒序一直追溯到创世区块的所有与请求有关的区块及交易组成的，而轻量客户端可以验证由完整节点返回的这条验证链，以确定其没有试图欺骗。

SPV功能的核心是由默克尔树（Merkle
Tree）支持的，这个会在后续章节具体实现中通过实例代码讲解其工作原理。

因此我们可以认为，在绝大多数的实际情况中，具有良好连接的轻量客户端是足够安全的，它在资源需求、实用性和安全性之间维持恰当的平衡。

当然，如果要保证万无一失的安全性，最可靠的方法还是运行完整的区块链节点。

#### 用智能合约对数据上锁

智能合约（英语：Smart
contract）是一种旨在以信息化方式传播、验证或执行合同的计算机协议。智能合约允许在没有第三方的情况下进行可信交易，这些交易可追踪且不可逆转。智能合约概念于1994年由Nick
Szabo首次提出。智能合约的目的是提供优于传统合约的安全方法，并减少与合约相关的其他交易成本。

而区块链上的智能合约则是一段写在区块链上的代码，并可以被所有区块链客户端传播、验证和执行的。它一般有以下特点：

-   智能合约由开发人员将某些约定以电子化的方式进行编程，代码中包含触发条件及自动执行内容；

-   一旦将这份智能合约上传到区块链网络上，陆续地，全网节点都会接收到这份智能合约，该智能合约会和区块链网络一起成为无法篡改的存在；

-   智能合约会被预定的事件触发，并在满足条件的时候执行对应的合约内容；

举例说明，销售手机充值卡（其实核心是交易充值密码），传统模式就是如下图，用户将钱给商铺，商铺把充值卡（充值密码）交给用户。

![](media/image31.png){width="5.073611111111111in"
height="1.0396041119860018in"}

如果同样的交易，我们把它放在区块链上，变成把手机充值密码以50区块链货币的价格销售给他人，那么这份智能合约就需要规定在你收到50区块链货币的同时，自动告知对方手机充值密码。

如下图，开发人员通过编程的方式，将上述触发条件及自动执行内容写成代码并上传至区块链网络。当对应事件触发，满足预设条件，如此处，当你收到对方发过来的50区块链货币时，程序自动检查条件满足，便执行告知对方手机充值密码这一动作。一切都是智能合约这个程序自动执行的，无人干预，也不能抵赖。

![](media/image31.png){width="5.073611111111111in"
height="1.0396041119860018in"}

需要说明的是，虽然比特币中已经有了智能合约这个概念（比特币中其实只称之为合约，或者分布式合约），但鉴于比特币是完全的电子货币设计，故其可编程的灵活性有限，且为了防止服务器被攻击，特意将可执行程序设计为图灵非完全（不支持循环等可能产生无法预估时间的操作），后期为了进一步预防服务器被攻击的风险，更多的早期版本所支持的命令都被取消了。

在以太坊的设计中，智能合约被作为重点考虑，通过执行代码需要收费这样的设计，使得程序设计为图灵完全，即可以用所有现代编程语言可以用的代码。

值得特别提出的是，智能合约因为固化在区块链，因此具有不可篡改性，也因此使得若其有缺陷的存在，也一样不可修复，一旦被发现缺陷的存在，常见处理方式有三种：

-   第一种方法，若有可能可尝试取消原智能合约，进而签订修复后的新智能合约；

-   第二种方法，回滚区块链，删除原智能合约签订后的所有区块，此法影响极大；

-   第三种方法，通过分叉修改现有共识，使得原智能合约无效，继而在修复后重新签订新的智能合约；

### 重要基础概念

区块链系统中有许多零碎的基础概念，它们是组成区块链生态的重要部分。这里面每个概念扩展开来，都能变成一本书的长度，鉴于本书是以实践为主，在后续的章节里，我们会使用具体编程实践的方式，去更加深入的理解每一个概念，这里只做简要讲解，方便读者在未完全掌握具体知识前，有一个初步的大体框架性概念。

#### 软分叉、硬分叉

区块链是一条链状，通过一条链将许多区块锁定在这个区块链上，然而因为多种理由，可能是人为的修改共识，也可能是正常共识阶段临时产生的不同步型分叉，使得一条链在某个分叉点后分成互相没有交集的两条链

在比特币的百科上有这样的描述：

-   硬分叉是在修改区块链协议后，使得在老客户端里面认为无效的区块或者交易，在新客户端当中认为是有效的。

-   软分叉是在修改区块链协议后，使得在老客户端里面认为有效的区块或者交易，在新客户端当中变得无效了。

这个基本定义比较绕口，形成一张表格如下：

           老客户端                       新客户端
  -------- ------------------------------ --------------------------------------
  硬分叉   识别新客户端产生的区块为无效   将产生老客户端无法识别的新区块
  软分叉   识别新客户端产生的区块为有效   可能会将老客户端产生的区块识别为无效

**硬分叉**

硬分叉是对协议的修改，启用了新的交易或区块格式，使得老客户端无法识别，因此要求所有客户端都要升级。通常情况下，对区块的结构、难度，共识的规则，或者改变有效的交易类型，都会产生硬分叉。但不是所有新增交易类型都必须使用硬分叉，也可以定义一种特殊的交易，使其对老客户端来看是有效交易（但其实无法真实的识别的交易），来增加新的交易种类。

硬分叉通常都是有意而为之的，通常都是由区块链的开发者煽动的，其通常情况会有两种结果。

-   第一种结果：一大批节点都不支持新的共识规则，继续使用以前老的共识（通常是老客户端）运作，这时候也有一定数量的节点开始使用新的共识规则（通常是新客户端）。那这个时候，两边不同的共识都会拒绝对方共识产生的区块，使得他们分裂成为两种不同的区块链（加密货币）。

-   第二种结果：大部分节点都同意更改共识规则，迫使使用老共识规则的节点，不得不改变他们的共识规则，改变成新共识规则，最终由所有节点共同产生一条新的区块链。

**软分叉**

软分叉是对协议的修改，使得老客户端可以将新的区块识别为合法的区块，所以说软分叉是向后兼容的。新的交易类型经常是以软分叉的方式添加进来，它只需要发送者和接收者以及对应的新客户端能够识别新的交易类型即可。在过去，P2SH和隔离见证都是通过这种方式添加到比特币当中的。

软分叉不需要所有节点都升级，就可以保持共识，因为由新客户端产生的所有区块，也都是符合老规则的，因此老客户端是可以接受这些区块的。

注意，网络上流传着另外一种解释，即软分叉的老客户端依旧可以产生新客户端可以识别的区块，以此使得老客户端能够在一段时间内不升级，这个说法不完全正确，因为老客户端无法识别新客户端新添加的功能，当然也无法将含有新功能的新交易或区块正确的打包，即有可能打包出老客户端认为是有效的区块，但是新客户端认为是无效的区块，长期来看，老客户端产生的区块可能会被新客户端拒绝而丧失获取奖励的机会。

举例来说，2017年8月启用的隔离见证功能，因为修改交易的结构，使得老客户端虽然能继续识别其新的数据结构，但没有对应的逻辑对新的交易进行验证，便可能出现将无效的交易当作有效的交易进行打包，并执行挖矿操作，但该区块广播到新客户端后，由于新客户端可以对新的交易进行验证，并发现其不合法，便拒绝该区块，使得老客户端辛苦的挖矿操作变得无意义。

因此在软分叉发生后，是有可能产生如下图所示的情况，即新老客户端均能产生互相识别为合法的区块，但随着该次分叉修改的程度高低，出现该种情况的几率呈负增长。

#### 拜占庭将军问题

拜占庭将军问题（Byzantine Generals
Problem）是区块链中为达成共识的基础问题，其故事有多个版本，其中一个可以这样说：

拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。
在战争的时候，拜占庭军队内所有将军和副官必须达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定又扰乱整体军队的秩序。在进行共识时，结果并不代表大多数人的意见。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，拜占庭问题就此形成。

![](media/image42.png){width="5.986807742782152in"
height="2.374232283464567in"}

图示：未达成共识的进攻计划会导致战争的失败。

在拜占庭问题里，最重要的事情是：所有将军如何能够达成共识。

转换到现代信息系统的问题就是：如何在不可信的通信通道和有叛徒节点的情况下达成共识。

在科学家们深入研究后，科学家们得出一个结论：如果叛徒的数量大于或等于1/3，拜占庭问题不可解。

比特币对此的解决方法，用形象的方式来描述，就是做一道非常难的数学题，来证明工作量，而这个工作量证明就增加了发送信息的成本，降低节点发送消息速率，这样就以保证在一个时间只有一个节点(或是很少)在进行广播，同时在广播时会附上自己的签名确保没有人可以伪造。

这个过程就像一位将军A在向其他的将军（B、C、D…）发起一个进攻提议一样，将军B、C、D…看到将军A签过名的进攻提议书，如果是诚实的将军就会立刻同意进攻提议，而不会发起自己新的进攻提议。

工作量证明其实相当于提高了做叛徒（发布虚假区块）的成本，在工作量证明下，只有第一个完成证明的节点才能广播区块，竞争难度非常大，需要很高的算力，如果不成功其算力就白白的耗费了（算力是需要成本的），如果有这样的算力作为诚实的节点，同样也可以获得很大的收益（这就是矿工所作的工作），这也实际就不会有做叛徒的动机，整个系统也因此而更稳定。

#### 授权区块链

授权区块链也常被称之为私有区块链（私链）、联盟区块链、混合区块链。与之相对的是无授权区块链，也称公共区块链，比特币、以太坊等一系列区块链便属于此种。

授权区块链使用访问控制层来管理区块链网络的访问权限。与公共区块链的网络相比，在授权区块链网络里的验证节点是由网络管理员审查并授予权限的，并不需要依赖任何一个匿名的节点来验证交易，因此授权区块链也并不能从网络效应（即随着匿名节点的增加，网络更加的稳定）中受益。在企业系统中，会更多的使用授权区块链。

其对比如下：

               授权区块链               公共区块链
  ------------ ------------------------ ------------------------------
  如何接入     授权接入                 开放接入
  法律与监管   可以符合法律及监管要求   目标就是创建一个反监管的网络
  如何做验证   由预选出的受信节点验证   匿名，完全分布式验证
  用途         企业级系统               完全公开的应用

如下图，绿色的表示记账节点，而红色的是匿名的成员节点，在公共区块链中，所有节点都可以是绿色的记账节点，但在授权区块链中，仅有通过授权的指定节点可以成为记账节点，其他成员节点只能发起或接受事务。

![图片包含 地图 已生成高可信度的说明](media/image43.tmp){width="6.0in"
height="2.029166666666667in"}

图示：左图为授权区块链，右图为公共区块链

基本的区块链程序
----------------

本章讲述了一个模仿比特币的区块链程序应有的基本模块，分别细节讲述区块链程序的基础结构、定义区块结构、复式记账交易结构和交易的确认及区块的验证与创建过程，本章结束时，一个基本的区块链程序已然成型，通过本章的配套源代码或是顺着本章的思路不断将代码自行录入后，您将可以自己执行这套程序，并详细查看运行过程，以更加深入的理解各个模块，以及各个模块之间的协同过程。

本章末尾还配有一些练习，可以在本章的源代码基础上，尝试对代码进行修改以增加或修改一些功能，以此加深对区块链程序的认识。

### 基础结构

鉴于是从零开始创建一个基本的区块链程序，我们本节会涉及到几个极其基础的结构和类。

#### 哈希计算

我们设计了以下Hash类进行计算，将一些常用操作进行封装，方便后续代码操作。

  ------------------------------------------------------------------------------------------------------
  1.  **public** **class** Hash  
  
  2.  {  
  
  3.      **private** **readonly** **byte**\[\] data;  
  
  4.      **public** Hash(**byte**\[\] origin)  
  
  5.      **public** Hash(IEnumerable&lt;**byte**\[\]&gt; origins)  
  
  6.      **public** Hash(**string** origin)  
  
  7.      **public** **static** **implicit** **operator** UInt256(Hash value)  
  
  8.      **public** **static** **implicit** **operator** **byte**\[\] (Hash value)  
  
  9.      **private** **static** **byte**\[\] SHA256Hash(**byte**\[\] bytes)  
  
  10.     **private** **static** **byte**\[\] SHA256Hash(IEnumerable&lt;**byte**\[\]&gt; bytesArray)  
  
  11.     {  
  
  12.         **if** (bytesArray == **null**)  
  
  13.         {  
  
  14.             **throw** **new** ArgumentNullException(nameof(bytesArray));  
  
  15.         }  
  
  16.   
  
  17.         **using** (var hash = SHA256.Create())  
  
  18.         {  
  
  19.             var e = bytesArray.GetEnumerator();  
  
  20.             **while** (e.MoveNext())  
  
  21.             {  
  
  22.                 var arr = e.Current;  
  
  23.                 hash.TransformBlock(arr, 0, arr.Length, **null**, 0);  
  
  24.             }  
  
  25.             hash.TransformFinalBlock(**new** **byte**\[\] { }, 0, 0);  
  
  26.             **return** hash.Hash;  
  
  27.         }  
  
  28.     }  
  
  29. }  
  
  ------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\Hash.cs

其中，

-   第3行：作为byte数组存在的哈希值；

-   第4-6行：接收几种不同的常见参数的构造器；

-   第7-8行：可隐式转换为UInt256或者byte数组；

-   第9-28行：做哈希计算的核心代码，主要是调用.Net框架中的SHA256类完成；

#### 256字节数字类型

在我们编写的程序里面会使用SHA256哈希计算方法，这也是比特币中主要的哈希计算方法。SHA256是安全散列算法SHA2系列算法之一，其摘要长度为256比特，即32个字节。

编程语言中通常情况会内置8位、16位、32位和64位的类，但对于256位的类，系统并未提供，虽然在较新版本的.NET框架中提供了BigInteger类也可以存储这样的大数，但其主要目的是存储用于计算的大数，对于我们的需求来看，会缺少转换、比较和限定的功能，因此为了后续在程序中方便的使用由SHA256输出的结果，我们设计了以下的UInt256类。

  ------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** UInt256 : IComparable&lt;UInt256&gt;    
  
  2.  {    
  
  3.      **public** **static** **readonly** UInt256 Zero = **new** UInt256(Enumerable.Repeat((**byte**)0, 32).ToArray());    
  
  4.      **private** **readonly** **byte**\[\] data;    
  
  5.      **public** UInt256(**byte**\[\] d)    
  
  6.      {    
  
  7.          **this**.data = d;    
  
  8.      }    
  
  9.      **public** **static** **bool** **operator** ==(UInt256 left, UInt256 right)    
  
  10.     **public** **static** **bool** **operator** !=(UInt256 left, UInt256 right)    
  
  11.     **public** **override** **bool** Equals(**object** obj)    
  
  12.     **public** **override** **int** GetHashCode()    
  
  13.     **public** **static** **implicit** **operator** **byte**\[\] (UInt256 value)    
  
  14.     **public** **static** UInt256 Parse(**string** str)    
  
  15.     **public** **override** **string** ToString()    
  
  16.     **public** **string** ToHex()    
  
  17.     **public** **int** CompareTo(UInt256 other)    
  
  18. }    
  
  ------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\UInt256.cs

其中，

-   第3行：定义了默认值0；

-   第4行：内部数据存储为byte型数组；

-   第5-8行：简单的初始化示意代码，数据设计为只读，使得该类为线程安全，并适合多线程程序的环境；

-   第9-12行：重载相等、不等操作符，方便比较两个UInt256类型是否一致；

-   第13行：鉴于该类型本质为byte型数组，故支持隐式转换；

-   第14-16行：将该类型与字符串之间进行转换，字符串的表现形式现在为16进制字符串形式，但在未来的Base58章节后，字符串的表现形式会发生变化；

-   第17行：实现IComparable&lt;UInt256&gt;接口，使得其支持排序；

#### 带哈希值的基类

在系统中有很多不同的类都需要含有哈希值这个属性，比如本章的区块类和交易类，所以这一节中先定义带有哈希值的基类。

首先定义一个拥有哈希值的类的接口：

  ----------------------------------------------------------------------
  1.  **public** **interface** []{#_Hlk518396777 .anchor}IHashObject  
  
  2.  {  
  
  3.      UInt256 Hash { **get**; }  
  
  4.  }  
  
  ----------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\IHashObject.cs

该接口比较简单，确立了拥有Hash这个属性的类的接口。

以此接口，实现一个通用型的抽象基类，未来该类会主要被作为区块和交易等基于哈希值的类的基础。

  -------------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **abstract** **class** HashBase : IHashObject  
  
  2.  {  
  
  3.      **private** UInt256 hash;  
  
  4.      **private** **bool** dirtyHash = **true**;  
  
  5.      **public** UInt256 Hash  
  
  6.      {  
  
  7.          **get**  
  
  8.          {  
  
  9.              **if** (**this**.dirtyHash)  
  
  10.             {  
  
  11.                 **this**.hash = **new** Hash(**this**.HashContent);  
  
  12.                 **this**.dirtyHash = **false**;  
  
  13.             }  
  
  14.   
  
  15.             **return** **this**.hash;  
  
  16.         }  
  
  17.     }  
  
  18.     **protected** **internal** **abstract** **string** HashContent { **get**; }  
  
  19.     **protected** **virtual** **void** OnPropertyChanged(**string** propertyName = **null**)  
  
  20.     {  
  
  21.         **this**.dirtyHash = **true**;  
  
  22.     }  
  
  23.     **protected** **void** SetPropertyField&lt;T&gt;(**ref** T field, T newValue, \[CallerMemberName\]**string** propertyName = "")  
  
  24.     {  
  
  25.         **if** (EqualityComparer&lt;T&gt;.Default.Equals(field, newValue)) **return**;  
  
  26.         field = newValue;  
  
  27.         **this**.OnPropertyChanged(propertyName);  
  
  28.     }  
  
  29.   
  
  30.     **public** **static** **bool** **operator** ==(HashBase a, HashBase b)  
  
  31.     **public** **static** **bool** **operator** !=(HashBase a, HashBase b)  
  
  32.     **public** **override** **bool** Equals(**object** obj)  
  
  33.     **public** **override** **int** GetHashCode()  
  
  34. }  
  
  -------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\HashBase.cs

其中，

-   第3行：哈希值的内部存储；

-   第4行：标记哈希值是否需要重新生成，默认为需要；

-   第5行：哈希值的对外的属性包装；

-   第7-16行：如果哈希值需要重新生成，则重新生成并返回，否则直接返回先前的值；

-   第18行：用于生成哈希值的信息全文，此处使用字符串主要是为了方便学习，未来会变成字节数组；

-   第19-22行：可由子类执行该方法，以告知该抽象基类已有属性发生变化，故需要重新生成哈希值的变量被置为需要，下次访问哈希值的时候，哈希值会被重新生成，以反映最新的属性情况；

-   第23-28行：方便子类编写属性的方法，内部逻辑为判断是否值发生变化，只有变化时才置新值，并将需要重新生成哈希值变量置为需要；

-   第30-33行：为方便比较两个基于该抽象基类的重载，具体比较即为比较哈希值这个属性；

基于该抽象基类的子类中的需要被考虑进哈希生成的属性，需要像以下方式编写：

  -------------------------------------------------------------------------------------
  1.  **public** **byte** Version  
  
  2.  {  
  
  3.      **get** =&gt; **this**.version;  
  
  4.      **set** =&gt; **this**.SetPropertyField(**ref** **this**.version, value);  
  
  5.  }  
  
  -------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\Transaction.cs

其中，

-   第3行：指向本类的内部字段；

-   第4行：调用基类的设置字段方法，可以简便的完成功能及避免重复代码；

### 定义区块结构

区块链是由许多区块按照时间顺序链接而成的，而每个区块中则存储有交易数据。我们可以这样理解，区块就是交易账本当中的每一页，而每页上面记录了所有交易的变更情况。所有交易都会放入交易池，而矿工负责选出适量的交易并打包成区块，最终添加到现有区块链的末尾。鉴于区块链上早先的区块会由于链条的变成而变得在链条上越来越深，因此会变得越来越难以修改。也正因如此，使得区块链具有很高的防篡改性。

#### 区块结构

  []{#_Hlk521677015 .anchor}字段   描述               类型
  -------------------------------- ------------------ -----------------
  Version                          版本号             Byte
  PreviousBlockHash                前一区块的哈希值   UInt256
  Time                             时间戳             DateTime
  Transactions                     所有交易           Transaction^\*^
  Nonce                            随机数             UInt32
  Hash                             本区块的哈希值     UInt256

参考代码：ClassicBlockChain\\Entity\\Block.cs

\*注：该类型会在下一节中具体解释，在此先介绍区块有助于对系统整体的理解。

该表格中的除了本区块的哈希值以外的所有字段，均会被作为本区块的哈希值计算的基础数据，故这些字段的任意一点变化均会导致本区块的哈希值的不同，以下对每个字段进行详细解释：

**版本号**。用以标记该区块的数据结构版本，从0开始，每次数据结构发生变化时，将该版本提升1。该版本发生变化，即认为分叉（分叉的解释可参见1.3.1软分叉、硬分叉）发生。软件系统可以借助于该字段来对系统进行升级变更。值得注意的是，区块链具有不可修改的特性，故与传统软件系统升级不同的是，区块链的升级通常需要保留对历史数据的处理代码的情况下，添加新的数据结构的处理代码。

**前一区块的哈希值**。将前一区块的哈希值记录在本区块的头部，使得区块之间形成链状，也是因此使得前一区块的任意修改，会导致后续链接的所有区块的哈希值的变化，使得原区块链断链，这会导致由于有计算量的存在，使得修改较早区块后变短的区块链在共识（共识将在后续章节中详细讲解）中失去竞争优势，最终不被区块链网络所认可而被抛弃，这也是区块链之所以成为链状结果，并能够防篡改的核心所在。

**时间戳**。创建该区块时的时间，由矿工填入，该字段只可以作为参考值，因为矿工可能因为私利而不诚实的填写该字段，在比特币网络中，并不会对该字段做验证，但通常情况，因为没有程序依赖该字段，错误的填写该字段并无法获利，故绝大数情况，该字段是填写正确，但无论如何绝对不可依赖该字段的值。

**所有交易**。每个区块均包含至少一笔交易，我们称之为CoinBase交易，也是我们常说的挖矿中挖到的矿。在比特币中，最初的CoinBase交易可获得50个比特币，而后每过210,000个区块后，交易可获得的比特币数量减半，直到所有的21,000,000个比特币被挖完。在我们的程序中简化为始终所有的CoinBase交易均为50个币。

**随机数**。为了在无任何受信三方存在公共网络环境中达成信任，比特币选择解决拜占庭将军问题（详见1.3.3）的工作量证明（详见1.3.1）。为了证明该名矿工进行了足够的工作量，矿工需要不断的修改该随机数，使得本区块的哈希值的十六进制表示中的前面指定位数的字符为0。对于比特币来说，指定位数会根据过去的2016个区块的耗费时间来调整，使得每个区块的平均工作量为10分钟。在本章的程序中，我们简化为固定难度，即始终是相同的指定位数，并不会进行调整。

**本区块的哈希值**。将以上所有字段的数据作为哈希运算的基础数据，计算出本区块的哈希值，但值得再次提出的是，只有这个哈希值的十六进制表示中的前面指定位数的字符为0时，才是有效的哈希值，即该区块有效，可以被视为区块链中的一个区块。

#### 区块随机数

我们使用以下程序寻找使得区块有效的随机数。

  ------------------------------------------------------------------------------------------
  1.  **private** **static** Block FindValidBlock(Block originBlock, **int** difficulty)  
  
  2.  {  
  
  3.      var block = originBlock;  
  
  4.      block.Nonce = 0;  
  
  5.      **while** (**true**)  
  
  6.      {  
  
  7.          block.Nonce++;  
  
  8.          **if** (((**byte**\[\])block.Hash).Take(difficulty).All(\_ =&gt; \_ == 0))  
  
  9.          {  
  
  10.             **return** block;  
  
  11.         }  
  
  12.     }  
  
  13. }  
  
  ------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

-   第4行：我们的随机数从0开始尝试；

-   第7行：我们每次循环就递增1，并判断是否使得区块有效了；

-   第8-11行：判断若符合指定难度，即返回有效的区块，注意：本章的程序简单的判断哈希值的前几位的字节原始数据，所以对应到比特币的实现来看，这里的难度相当于翻倍了；

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  扩展知识
  
  关于随机数，有一个常见的问题，如果随机数循环找完了所有的可能性，仍旧没有找到使得区块有效的随机数，这时应该怎么办？
  
  该随机数的类型为整形32位，即最大值为4,294,967,295，虽算是一个大数字，但在难度不断增加的情况下，这个数字仍旧很容易被用尽，不过遇到这样的情况，只需要将时间戳字段更新为当前的时间，重新从0开始计算即可。
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#### 创世区块

创世区块的定义如下代码：

  ----------------------------------------------------------------------------
  1.  GenesisBlock = FindValidBlock(**new** Block  
  
  2.  {  
  
  3.      PreviousBlockHash = **null**,  
  
  4.      Time = **new** DateTime(2017, 6, 30, 9, 0, 0, DateTimeKind.Utc),  
  
  5.      Version = BlockChainVersion,  
  
  6.      Transactions = **new** Transaction\[\] { },  
  
  7.  }, Difficulty);  
  
  ----------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

区块链是一系列的区块链接在一起的，这其中第一个区块，即为创世区块。它有如下几个特点：

-   从时间上讲，该区块是第一个被创建出来的；

-   从特点上讲，该区块是区块链中唯一一个没有前一区块的哈希值的区块；

-   从内容上讲，该区块的内容通常可以由创世者随意指定，例如本章范例代码中，时间使用了固定值，而非创建时的确定值，也例如创世区块中无任何交易（比特币设计为创世区块中含有一笔CoinBase交易）；

在比特币中，创世区块的哈希值是写在代码中的，不过我们此处为了让读者了解到该哈希值的生成过程，所以设计成运行时生成的模式，有兴趣的读者可以通过调试方法在运行时查看该哈希值的生成过程。

### 复式记账交易结构

比特币使用了复式记账方法，通过这种方法，一是可以了解每一笔资金的来龙去脉，并能完整、系统的反映出整个资金传递过程；二是可以据此验证资金平衡，以检查账户资金记录的正确性。这是一种极其科学的交易记录方式。

#### 交易的源头

所有交易的源头都是CoinBase交易，也就是说，任何一笔加密货币中可使用的资金，均可以通过寻找源头找到最初创造出该笔资金的CoinBase交易，所以CoinBase交易本身可以认为就是一种创造货币的交易，该创造货币的过程就是区块打包的过程，由此创造出来的货币也是用来奖励矿工的辛苦计算的。

#### 链式交易结构

当Alice想要向Bob付钱时，她需要确认自己的钱包中有足够的金额，于是她确认了钱包里有Miner之前付给她的钱，于是她才可以把这笔钱付给Bob，而Miner付给她的这笔钱，也是由区块链网络确认其创建区块的辛苦计算而奖励的金额。而Bob获得Alice付给的钱后，他便可以将这笔钱进行整体或者分拆使用。如下表，即为前面这段描述作为链式交易结构的展现。

  所属区块   交易编号   发送者   接收者   金额
  ---------- ---------- -------- -------- ------
  88         324        无       Miner    50
  89         325        Miner    Alice    30
  90         326        Alice    Bob      30
  91         327        Bob      Other    10

其中，所属区块和交易编号均为随意选择的一个数字，主要用来标记其为连续的多个区块或交易，而88区块中的324交易为源头的CoinBase交易，即由矿工Miner创造了货币。

复式记账中有“找零”的设计，即若未一次性支付完，需要将多余的部分支付给自己，作为找零。因此在复式记账的区块链程序中有一个非常重要的概念，即未使用的交易，而所有试图使用的资金都必须是未使用过的，这个过程类似于实物一般的金币，当你把金币递给别人后，你就不可能再使用一次这一颗金币了，因为它已经没有在你的手上了。

以下，我们添加上找零和**未使用交易**概念，形成以下这个完全符合复式记账区块链网络的交易表格。

  所属区块   交易编号   发送者   接收者   金额
  ---------- ---------- -------- -------- ------
  88         324        无       Miner    50
  89         325-1      Miner    Alice    30
             325-2      Miner    Miner    20
  90         326        Alice    Bob      30
  91         327-1      Bob      Other    10
             327-2      Bob      Bob      20

其中，矿工Miner在将手中的50货币中的30货币发送给Alice（交易编号325-1）的同时，也给自己钱包里面放了20货币（交易编号325-2），因此原本的50货币被分成了30和20两个可以独立拥有和使用的个体。

最后Bob在将手中的30货币中的10货币发送给他人（交易编号327-1）的同时，也给自己找零了20货币（交易编号327-2）。

我们继续使用下表，看一下在每一个区块处理完成时的交易及个人余额的状态：

               交易状态   各人余额
  ------------ ---------- ---------- ------- ------ ------- ------- ------- ------- -----
  已处理区块   324        325-1      325-2   326    327-1   327-2   Miner   Alice   Bob
  88           未用       -          -       -      -       -       50      -       -
  89           已用       未用       未用    -      -       -       20      30      -
  90           已用       已用       未用    未用   -       -       20      0       30
  91           已用       已用       未用    已用   未用    未用    20      0       20

其中，

-   区块88处理完成时：只有Miner一人获得了创造区块的矿工奖励50，该CoinBase交易（编号324）被标记为未使用的交易；

-   区块89处理完成时：Miner将钱分成两笔（编号325-1和325-2）分别给了Alice和自己，原CoinBase交易（编号324）被标记为已使用，故未来Miner不能再次使用该笔交易，所以此时他的余额仅为20。

-   区块90处理完成时：Alice将她在编号325-1交易所拥有的钱发送给了Bob，该交易状态变为已用，而Bob获得货币的交易（编号326）则为未使用的交易，此时Alice因为用完所有钱，余额为0；

-   区块91处理完成时：类似于区块89
    的处理过程，Bob将他在编号326交易所拥有的钱发给他人，并向自己找零，使得原交易326变为已使用交易，余额也变为新产生的交易327-2所指示的20货币；

以上便是整个交易的处理过程，以下用更加形象的图例展示了整个过程。

  Miner   50   20   20   20
  ------- ---- ---- ---- ----
  Alice   -    30   0    0
  Bob     -    -    30   20
  Other   -    -    -    10

另外还值得注意的是，除了上面提到的这些机制以外，比特币网络中还设计有交易费用，这个也是非常重要的设计，尤其是当所有有奖励的比特币区块都挖掘完成时，整个网络的运营就是靠交易费进行维持的。但本章示例的基本程序并未涉及该部分。

#### 交易的结构

  字段                描述             类型
  ------------------- ---------------- ---------------------------
  Version             版本号           Byte
  MetaData            任意字符串       String
  InputTransactions   输入交易列表     UInt256\[\]
  OutputOwners        接收者列表       TransactionOutput\[\]^\*^
  Hash                本交易的哈希值   UInt256

参考代码：ClassicBlockChain\\Entity\\Transaction.cs

\*注：该类型如以下代码所示，非常简单的仅有接收者和货币数量两个字段。

  -------------------------------------------------------------
  1.  **public** **class** TransactionOutput  
  
  2.  {  
  
  3.      **public** **string** Owner { **get**; **set**; }  
  
  4.      **public** **int** Value { **get**; **set**; }  
  
  5.  }  
  
  -------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\TransactionOutput.cs

该表格中的除了本交易的哈希值以外的所有字段，均会被作为本交易的哈希值计算的基础数据，故这些字段的任意一点变化均会导致本交易的哈希值的不同，以下对每个字段进行详细解释：

**版本号**。用以标记该交易的数据结构版本，从0开始，每次数据结构发生变化时，将该版本提升1。该版本发生变化，即认为分叉（分叉的解释可参见1.3.1软分叉、硬分叉）发生。软件系统可以借助于该字段来对系统进行升级变更。值得注意的是，区块链具有不可修改的特性，故与传统软件系统升级不同的是，区块链的升级通常需要保留对历史数据的处理代码的情况下，添加新的数据结构的处理代码。

**任意字符串**。虽然比特币的交易中也确实有类似的用法，比如比特币创世区块中那条著名的话语。但在本章程序中，该字符串存在的目的，主要还是为了让后续类似的交易拥有不同的交易哈希值。在比特币的设计中，由于有对交易的签名，而签名的哈希内容中包含了未使用交易的哈希值，故天然不会出现重复的哈希值。在下一章中，会具体讲解签名的过程，因此进入到下一章后，该字段会被取消。

**输入交易列表**。作为本次交易资金源头输入的未使用交易列表，列表项均为未使用交易的哈希值。在比特币的设计中，每个列表项应该包含未使用交易的哈希和接收者列表中排序号，在本章的代码中，此部分被省略，在下一章签名过程后，该部分代码会被补全。

**接收者列表**。作为本次交易的输出，列表项均包含接收者名称和资金数量两个字段，在比特币的设计中，接收者是以比特币地址存在，本章程序为使学习者更易理解，使用简单的文本代替，在下一章交易签名学习之后，该地址便会转化成与比特币相仿的地址。

**本交易的哈希值**。将以上所有字段的数据作为哈希运算的基础数据，计算出本交易的哈希值，但值得特别强调的是，区块链中所有的交易的哈希值都是不一样的，不会有重复的，相同哈希值的交易会在验证步骤被当作重复交易去除掉。

### 区块的验证与创建

到此为止，区块链上最重要的数据结构——区块及交易的数据结构已经讲解清楚了，在本节里将整合前面完成的数据结构，让系统能够持续性的确认交易并创建新的区块。

#### 将区块存成链状

为了方便的管理区块的链式结构，我们在此设计了一个BlockChain类，用于管理整个区块链的数据结构。

  -----------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** BlockChain  
  
  2.  {  
  
  3.      **private** **const** **byte** Difficulty = 2;  
  
  4.      **private** **const** **byte** BlockChainVersion = 1;  
  
  5.      **public** **static** **readonly** Block GenesisBlock;  
  
  6.      **private** **readonly** **int** MaxTransactionNumberInBlock = 1000;  
  
  7.      **internal** **readonly** **int** RewardOfBlock = 50;  
  
  8.    
  
  9.      **public** BlockChain()  
  
  10.     {  
  
  11.         **this**.InitBlocks(GenesisBlock);  
  
  12.         **this**.Tail = GenesisBlock;  
  
  13.     }  
  
  14.   
  
  15.     **public** ConcurrentDictionary&lt;UInt256, Block&gt; BlockDictionary { **get**; }  
  
  16.     **internal** ConcurrentDictionary&lt;UInt256, (Block head, **int** index)&gt; TransactionToBlockDictionary { **get**; }  
  
  17.     **internal** ConcurrentDictionary&lt;UInt256, **byte**&gt; UsedTransactionDictionary { **get**; }  
  
  18.     **public** **int** Height =&gt; **this**.BlockDictionary.Count;  
  
  19.     **public** Block Tail { **get**; **set**; }  
  
  20.     **private** ConcurrentQueue&lt;Transaction&gt; TransactionQueue { **get**; }  
  
  21.   
  
  22.     **internal** **bool** ContainTransaction(UInt256 tranHash)  
  
  23.     **internal** **void** AddTransaction(Transaction transaction)  
  
  24.     **internal** Block AddBlock(Block block)  
  
  25.     **internal** **bool** ContainUsedTransactions(UInt256\[\] inputTransactions)  
  
  26.     **internal** **void** InitBlocks(**params** Block\[\] blocks)  
  
  27.     **private** **static** Block FindValidBlock(Block originBlock, **int** difficulty)  
  
  28.     **internal** Transaction\[\] DequeueTransactions()  
  
  29.     **internal** Transaction GetTransaction(UInt256 hash)  
  
  30.     **private** **void** MaintainBlockChain(Block newTail)  
  
  31.     **private** **void** MaintainChainDictionary(Block from, Block to)  
  
  32. }  
  
  -----------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

-   第3行：当前区块链的计算难度，本章中设定为常数，且为比特币难度概念的翻倍；

-   第4行：当前区块链支持区块数据结构的版本号；

-   第5行：一个区块中可以存储的最大交易数量，本章简化为以数量计算，比特币的实际情况为按照交易的总字节数，最大不超过1M来计算（隔离见证的情况，会略有例外）；

-   第6行：每个区块成功后，矿工可以获得奖励，比特币的实际情况是按照区块数量进行不断减半，直到最后不再有奖励；

-   第7行：存储创世区块；

-   第9-13行：在初始化区块链的时候，即会立即将创世区块添加至其链上，作为创建时的第一和唯一的一个区块；

-   第15行：存储了所有区块信息，并使用哈希值进行索引；

-   第16行：存储了从交易的哈希值到区块的索引，方便后续可以快速的找到交易；

-   第17行：存储了已经被使用过的交易信息，此处其实可以使用HashSet，但为保证线程安全，简单的使用了线程安全的字典类；

-   第18行：区块的高度，本章内容里，这里简单的使用了区块的总量，但值得注意的是，在后续章节，支持共识后，区块总量可能会大于实际的高度，因为可能有共识失败残留下的临时分叉区块；

-   第19行：尾部区块，即最后一个区块，这个也是整个有效区块链的入口，所有搜索都会从这个地方进入；

-   第20行：交易池，存储了所有待入块的交易；

-   第22行：判断在区块链中是否包含指定哈希值的交易；

-   第23行：添加一笔交易至交易池中；

-   第24行：添加一个区块，添加的区块可以不用填写随机值，该方法会在内部试图寻找使得区块有效的随机值，并在填写后返回该有效的区块；

-   第25行：根据一系列的输入交易的哈希值判断是否已经被使用过了；

-   第26行：批量初始化一个或多个区块，必须是有效的区块；

-   第27行：通过遍历所有可能的随机数，寻找有效的区块；

-   第28行：从交易池中取出准备放入区块的交易；

-   第29行：根据交易的哈希值获得对应的交易信息；

-   第30-31行：维护区块链的索引；

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  隔离见证
  
  隔离见证是比特币扩容的一种方案，此方案已经于2017年8月在比特币网络上被采用。
  
  中本聪在最初比特币源代码中明确规定了每一个区块大小不超过1M。若要对此做出改变，必然形成硬分叉，这是整个比特币界乃至区块链界都非常谨慎的事情。
  
  而隔离见证就是把脚本签名(scriptSig)信息从基本结构里拿出来，放在一个新的数据结构当中。做验证工作的节点和矿工也会验证这个新的数据结构里的脚本签名，以确保交易是有效的。
  
  当审核统计区块的容量不能超过1M的时候，透过隔离见证，独立出的脚本签名，其大小便不会被计算在内，其实也是利用了早期区块链客户端对区块大小验证上的小疏漏。
  
  以下图示以火车车厢运送货物，来清楚的表达隔离见证：
  
  图中上半部分是未采用隔离见证的一个区块，以火车的一节车厢作为比喻，而每一笔交易则是以黄色与蓝色的货物做为代表，分别是脚本签名，以及交易的基本结构。
  
  ![](media/image44.jpeg){width="3.653465660542432in" height="2.402484689413823in"}
  
  原比特币代码仅规定了火车车厢的宽度，并未规定高度，所以藉由把脚本签名从每一笔交易中独立出来，原先只能载三个货物的车厢，便可以容纳七个货物了。
  
  也就是说，原先只能容纳三笔交易的一个区块，透过隔离见证，便可以一次传输七笔交易，很好的解决的比特币的扩容问题。
  
  另外，隔离见证分成两个部分，以上描述的为第一部分，即通过软分叉与未激活隔离见证的节点实现很好的过渡，第二部分描述了不用分叉而直接扩容的方法，在全网大部分节点均激活了隔离见证后，第二部分的扩容方案即可启用。
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#### 管理区块的创建过程

区块的创建过程是需要算力的，而程序需要一边接受用户的交易请求，一边同时处理打包区块的事务，所以我们使用以下Engine类管理区块的创建过程，使其正常稳定的在独立线程中运行，而不影响主线程处理用户的交易请求。

  ---------------------------------------------------------------------------------
  1.  **public** **class** Engine : IDisposable  
  
  2.  {  
  
  3.      **public** **readonly** BlockChain BlockChain;  
  
  4.      **private** **readonly** Thread thWorker;  
  
  5.      **private** **bool** disposing = **false**;  
  
  6.      **public** **event** EventHandler&lt;Block&gt; OnNewBlockCreated;  
  
  7.      **private** **readonly** **string** MinerName;  
  
  8.    
  
  9.      **public** Engine(**string** minerName)  
  
  10.     {  
  
  11.         **this**.MinerName = minerName;  
  
  12.         **this**.BlockChain = **new** BlockChain();  
  
  13.         **this**.thWorker = **new** Thread(**this**.GenerateBlockThread);  
  
  14.         **this**.thWorker.Start();  
  
  15.     }  
  
  16.   
  
  17.     **public** UInt256 AttachTransaction(Transaction transaction)  
  
  18.     **private** **void** GenerateBlockThread(**object** state)  
  
  19.     **private** Block GenerateBlock()  
  
  20.     **private** **bool** ValidateTransaction(Transaction tran)  
  
  21.     **public** **void** Dispose()  
  
  22.     {  
  
  23.         **this**.disposing = **true**;  
  
  24.         **this**.thWorker.Join();  
  
  25.     }  
  
  26. }  
  
  ---------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\Engine.cs

其中，

-   第3行：包含区块链的管理类；

-   第4行：独立运行的线程，可以在不影响主进程的情况下进行PoW的计算；

-   第5行：是否进入到结束状态；

-   第6行：新区块创建成功后事件；

-   第7行：矿工的名字，用于挖矿成功后，将对应的奖励发送给矿工；

-   第9-15行：初始化类，基本赋值，并启动产生区块的独立线程；

-   第17行：接受用户请求，添加一条交易请求到交易池中；

-   第18行：生成区块的独立线程逻辑；

-   第19行：生成区块的主要逻辑；

-   第20行：验证交易是否有效且可执行的逻辑；

-   第21-25行：释放区块链的逻辑，将生成区块的独立线程优雅地停下来；

其中该类在本章阶段里，最重要的就是管理区块的生成过程，我们将区块的生成过程放在独立的线程中操作，即以下方法：

  -------------------------------------------------------------------------------------------
  1.  **private** **void** GenerateBlockThread(**object** state)  
  
  2.  {  
  
  3.      **while** (!**this**.disposing)  
  
  4.      {  
  
  5.          **try**  
  
  6.          {  
  
  7.              var block = **this**.GenerateBlock();  
  
  8.              **this**.OnNewBlockCreated?.Invoke(**this**, block);  
  
  9.          }  
  
  10.         **catch** (Exception ex)  
  
  11.         {  
  
  12.             Console.WriteLine(\$"Error when generating new block\[{ex.Message}\]");  
  
  13.         }  
  
  14.     }  
  
  15. }  
  
  -------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\Engine.cs

其中，

-   第3行：本段代码在程序释放之前都会重复执行，以不断产生新的区块，故只有当需要释放程序的控制变量变化时才退出循环；

-   第5-13行：独立线程的主程序，为保证线程不会因为意外完全停止工作，我们对通用异常进行一次处理；

-   第7行：我们通过一个子程序生成区块，并将其挂载在区块链末尾，最后返回该有效的区块

-   第8行：以事件的方式通知外部程序区块的产生，以便外部程序进行相应处理；

#### 从交易池中取出交易

打包交易的第一步便是需要从交易池中将指定数量的用户请求取出来，以便后续步骤进行验证后打包至区块中，这里是取出交易的方法：

  -----------------------------------------------------------------------------
  1.  **internal** Transaction\[\] DequeueTransactions()  
  
  2.  {  
  
  3.      var dict = **new** Dictionary&lt;UInt256, Transaction&gt;();  
  
  4.      **while** (**this**.TransactionQueue.TryDequeue(**out** var tran)  
  
  5.          && dict.Count &lt; **this**.MaxTransactionNumberInBlock)  
  
  6.      {  
  
  7.          **if** (!dict.ContainsKey(tran.Hash))  
  
  8.              dict.Add(tran.Hash, tran);  
  
  9.          **else**  
  
  10.             dict\[tran.Hash\] = tran;  
  
  11.     }  
  
  12.   
  
  13.     **return** dict.Select(\_ =&gt; \_.Value).ToArray();  
  
  14. }  
  
  -----------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

-   第3行：临时建立一个字典，主要目的是对交易池内的交易进行排重；

-   第4-5行：不断循环，直到交易池中没有交易或者当前有效交易数量达到我们设定的区块中交易数量，注意，实际生产中应考虑验证交易的有效性而不仅仅是排重后进行输出，这样才能实际的控制区块中的最终交易数量；

-   第7-10行：排重性的添加，若不存在则添加；

-   第13行：返回已经排重的结果；

#### 交易的确认

取出交易过后进行交易的验证，确认交易合法且可加入到区块后，将成为后续打包步骤的输入，此处使用此方法验证交易。

  ----------------------------------------------------------------------------------------
  1.  **private** **bool** ValidateTransaction(Transaction tran)  
  
  2.  {  
  
  3.      **return** !**this**.BlockChain.ContainTransaction(tran.Hash)  
  
  4.          && !**this**.BlockChain.ContainUsedTransactions(tran.InputTransactions);  
  
  5.  }  
  
  ----------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\Engine.cs

其中，

-   第3行：确认该交易的哈希值没有在现在的区块链上出现，即没有相同的交易，重复交易时不被允许的；

-   第4行：确认该交易不是已经被使用过的交易，任何交易都只能被使用一次；

以下是确认交易存在的方法实现：

  ------------------------------------------------------------------------------
  1.  **internal** **bool** ContainTransaction(UInt256 tranHash)  
  
  2.      =&gt; **this**.TransactionToBlockDictionary.ContainsKey(tranHash);  
  
  ------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

-   第2行：
    该方法简单的对已经维护妥当的区块链中的交易到区块的映射表进行查找即可；

以下是确认输入交易使用过的方法实现：

  ---------------------------------------------------------------------------------------------
  1.  **internal** **bool** ContainUsedTransactions(UInt256\[\] inputTransactions)  
  
  2.  {  
  
  3.      **foreach** (var tran **in** inputTransactions)  
  
  4.      {  
  
  5.          **if** (**this**.UsedTransactionDictionary.TryGetValue(tran, **out** var \_))  
  
  6.              **return** **true**;  
  
  7.      }  
  
  8.    
  
  9.      **return** **false**;  
  
  10. }  
  
  ---------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

-   第3-7行：将每一个输入交易进行遍历判断；

-   第5-6行：在已经使用的交易列表中进行简单的查找，已确认其是否存在；

-   第9行：若没有找到存在，则返回否；

#### 将交易打包

该方法是由独立的区块打包线程调起的，主要就是从交易池中取出有效的交易，在加上奖励矿工的CoinBase交易后一起打包成功区块的。

  ---------------------------------------------------------------------------------------------------------------------------------------------------
  1.  **private** Block GenerateBlock()  
  
  2.  {  
  
  3.      var finalTrans = **this**.BlockChain.DequeueTransactions()  
  
  4.          .Where(**this**.ValidateTransaction)  
  
  5.          .ToList();  
  
  6.    
  
  7.      var minerTran = **new** Transaction  
  
  8.      {  
  
  9.          OutputOwners = **new**\[\] { **new** TransactionOutput { Owner = **this**.MinerName, Value = **this**.BlockChain.RewardOfBlock } },  
  
  10.         MetaData = DateTime.Now.Ticks.ToString(),  
  
  11.     };  
  
  12.     var allTrans = **new**\[\] { minerTran }.Concat(finalTrans).ToArray();  
  
  13.   
  
  14.     var prevBlock = **this**.BlockChain.Tail;  
  
  15.     var block = **this**.BlockChain.AddBlock(**new** Block  
  
  16.     {  
  
  17.         PreviousBlockHash = prevBlock.Hash,  
  
  18.         Time = DateTime.Now,  
  
  19.         Transactions = allTrans,  
  
  20.     });  
  
  21.     **return** block;  
  
  22. }  
  
  ---------------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\Engine.cs

其中，

-   第3-5行：从区块链的交易池中取出交易，并通过ValidateTransaction方法进行验证，留下通过验证的交易，其他不能通过验证的交易就丢弃掉；

-   第7-11行：创建一笔CoinBase交易，向矿工自己的钱包发送一笔奖励资金，其中由于本章未实现交易签名，故在MetaData相同的情况，同一矿工的所有CoinBase交易都会有相同的哈希值，故此处将MetaData填入一个随着时间发生变化的值，便能保证短时间的运行周期内不发生重复；

-   第12行：将CoinBase交易与普通用户的交易放在一起，准备打包进区块；

-   第14行：从区块链中找到尾部的区块，我们将从该尾部区块开始延生；

-   第15-20行：构造一个区块，并让区块链管理模块进行具体区块有效化和创建的操作，最终返回已添加成功的有效区块；

-   第17行：前一个区块的哈希值，这也是让区块形成区块链的核心；

-   第18行：记录当前的时间；

-   第19行：包含所有的有效交易；

-   第21行：将生成成功的有效区块返回出去；

#### 区块创建过程

此处将前一步骤中已经打包完成的区块进行最后一道工序的处理，填上正确的版本号和随机数，并最终放入区块链中。

  ------------------------------------------------------
  1.  **internal** Block AddBlock(Block block)  
  
  2.  {  
  
  3.      block.Version = BlockChainVersion;  
  
  4.      block = FindValidBlock(block, Difficulty);  
  
  5.    
  
  6.      **this**.InitBlocks(block);  
  
  7.      **return** block;  
  
  8.  }  
  
  ------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

-   第3行：确保区块的版本号为当前区块链的版本号；

-   第4行：通过计算，找到一个有效的区块；

-   第6行：将新创建的区块加入到现有的区块链中去；

-   第7行：返回当前找到的有效区块，同时这个区块也是已经顺利添加到区块链末尾的区块；

在最后放入区块链前做的最后交易的检查，属于防御性代码。

  -----------------------------------------------------------------------------------------------------
  1.  **private** (**bool** ret, **string** error) CheckQueueOfTransaction(Transaction transaction)  
  
  2.  {  
  
  3.      **if** (**this**.GetTransaction(transaction.Hash) != **null**)  
  
  4.      {  
  
  5.          **return** (**false**, "transaction you submit already exist in chain.");  
  
  6.      }  
  
  7.    
  
  8.      **if** (**this**.TransactionQueue.Any(\_ =&gt; \_.Hash == transaction.Hash))  
  
  9.      {  
  
  10.         **return** (**false**, "transaction you submit already exist in queue.");  
  
  11.     }  
  
  12.   
  
  13.     **return** (**true**, **null**);  
  
  14. }    
  
  -----------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

-   第3-6行：若该交易已经存在于区块链上，则返回错误信息；

-   第8-11行：若该交易已经存在于交易池中，则返回错误信息；

-   第13行：若无错误，则直接返回正确的处理结果；

此方法假设前置步骤已经将准备放入区块链中的区块验证和准备妥当了，此处便进行具体的放入操作并调起区块链维护代码。

  ---------------------------------------------------------------------
  1.  **internal** **void** InitBlocks(**params** Block\[\] blocks)  
  
  2.  {  
  
  3.      **foreach** (var block **in** blocks)  
  
  4.      {  
  
  5.          **this**.BlockDictionary\[block.Hash\] = block;  
  
  6.      }  
  
  7.    
  
  8.      **this**.MaintainBlockChain(blocks.Last());  
  
  9.  }  
  
  ---------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

-   第3-6行：依次将区块放入区块的存储区，以区块的哈希值为索引，以便未来引用，本代码块假定区块已经通过验证，为有效的区块；

-   第8行：从最后一个区块为起点，维护区块链，此处也假定了区块是顺序的排放的；

#### 维护区块链

为了保证区块链能够高效的运行，我们需要一些索引来处理一些访问的请求，因此我们需要对区块链进行维护。

  -------------------------------------------------------------------------------------------------------------
  1.  **private** **void** MaintainBlockChain(Block newTail)  
  
  2.  {  
  
  3.      var prevTail = **this**.Tail;  
  
  4.    
  
  5.      **this**.Tail = newTail;  
  
  6.      **if** (**this**.Tail != prevTail) **this**.MaintainChainDictionary(GenesisBlock, **this**.Tail);  
  
  7.  }  
  
  -------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

-   第3行：先记录当前的尾部区块；

-   第5行：将当前的尾部区块赋值为新的尾部区块；

-   第6行：若新的尾部区块与先前不同，则启动维护区块链字典的程序，范围是从创世区块到新的尾部；

以下方法通过遍历从尾部到指定头部之间的区块，以确保新加入的区块中的所有交易都被放入交易的索引字典中，为后续调用做好了准备。

  ---------------------------------------------------------------------------------------------------------
  1.  **private** **void** MaintainChainDictionary(Block from, Block to)  
  
  2.  {  
  
  3.      var cursor = to;  
  
  4.      **while** (cursor.Hash != from.Hash)  
  
  5.      {  
  
  6.          var block = **this**.BlockDictionary\[cursor.Hash\];  
  
  7.          **if** (block.Transactions != **null**)  
  
  8.          {  
  
  9.              **for** (**int** i = 0; i &lt; block.Transactions.Length; i++)  
  
  10.             {  
  
  11.                 var tran = block.Transactions\[i\];  
  
  12.                 **this**.TransactionToBlockDictionary\[tran.Hash\] = (cursor, i);  
  
  13.                 **foreach** (var usedTx **in** tran.InputTransactions ?? **new** UInt256\[\] { })  
  
  14.                 {  
  
  15.                     **this**.UsedTransactionDictionary\[usedTx\] = 0;  
  
  16.                 }  
  
  17.             }  
  
  18.         }  
  
  19.   
  
  20.         cursor = **this**.BlockDictionary\[cursor.PreviousBlockHash\];  
  
  21.     }  
  
  22. }  
  
  23. 
  ---------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

-   第3行：整体程序结构使用游标的方式进行，而且鉴于区块链的数据结构是从尾部指向前一区块，直到最后指到创世区块为止；

-   第4行：结束的条件是游标到达方法入口指定的起始区块，在本节的场景中，该起始区块其实就是创世区块；

-   第6行：我们先从区块字典（数据库）中获得区块的信息；

-   第7行：确定区块的交易字段不为空，正常情况下，除了创世区块之外并无区块会有此种情况，此处主要是防御型代码；

-   第9-17行：遍历区块中的所有交易；

-   第11行：取出当前准备遍历的交易信息；

-   第12行：依此信息更新交易到区块的映射关系，使得我们未来可以快速的找到任意一笔交易，且知道该笔交易所属的区块；

-   第13-16行：将所有的输入交易都加入到已使用的交易列表中，为下次创建区块时判断交易是否已经被使用过做好准备；

-   第20行：将游标指向前一区块，继续推进遍历；

### 本章练习

至此，本章的主程序已经全部解析完成，在本节中，通过基本练习，完成程序的入口及基本测试用例，通过调试的方式亲自看一下区块链是如何运行的；通过扩展练习，完成一些本章未涉及到的知识点，进一步提升自己的区块链编程能力。

#### 基本练习一 运行程序并观察

本章程序可以通过一个标准的控制台程序进行运行查看，此处为入口代码。

  ------------------------------------------------------------------------------
  1.  **private** **static** **void** Main(**string**\[\] args)    
  
  2.  {    
  
  3.      Console.WriteLine(\$"Press any key to stop....");    
  
  4.      var engine = **new** Engine(myName);    
  
  5.      Console.WriteLine(\$"Genesis Block: {BlockChain.GenesisBlock}");    
  
  6.      engine.OnNewBlockCreated += Engine\_OnNewBlockCreated;    
  
  7.      Console.ReadKey();    
  
  8.  }    
  
  ------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Program.cs

其中，

-   第3行：该程序设计为按任意键结束程序；

-   第4行：启动Engine类，并传入矿工的名字，以获取挖矿的奖励；

-   第5行：打印创世区块的信息，方便查看和理解；

-   第6行：监听新区块创建的事件；

-   第7行：按任意键即结束程序，否则程序将持续的运行下去；

上面提到监听新区块创建的事件，这个是这个事件的处理代码，主要是打印新创建区块信息。

  ------------------------------------------------------------------------------------------------------------
  1.  **private** **static** **void** Engine\_OnNewBlockCreated(**object** sender, Block block)    
  
  2.  {    
  
  3.      var engine = sender **as** Engine;    
  
  4.      var height = engine.BlockChain.Height;    
  
  5.      Console.WriteLine(\$"New block created at height\[{height:0000}\]: {engine.BlockChain.Tail}");    
  
  6.  }    
  
  ------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Program.cs

其中，

-   第3-5行：将新创建区块的信息打印出来；

下面是交易的打印代码片段：

  -----------------------------------------------------------------------------------------------------------------------
  1.  **protected** **override** **string** DebuggerDisplay =&gt; \$"" +  
  
  2.      \$"{this.Hash.ToShort()}: " +  
  
  3.      \$"({string.Join(",", this.OutputOwners?.Select(\_ =&gt; \_.ToString()) ?? new string\[\] { })}) &lt;-- " +  
  
  4.      ((**this**.InputTransactions != **null** && **this**.InputTransactions.Length &gt; 0)  
  
  5.          ? \$"({string.Join(",", this.InputTransactions.Select(\_ =&gt; \_.ToShort()))})"  
  
  6.          : \$"(Coin Base)");     
  
  -----------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\Transaction.cs

其中，

-   第2行：打印简短版的哈希值；

-   第3行：把每个接收者及其接收值打印出来，类似于：“(Alice:
    50)”或“(Alice: 20, Bob:30)”；

-   第4行：根据是否有输入的交易打印不同的信息；

-   第5行：若有输入的交易，则将哈希值的简短形式其打印出来，类似于：“(95280182E2)”；

-   第6行：若无输入的交易，则为CoinBase交易，故直接打印CoinBase字符串；

最终整体打印出的结果类似于：“95280182E2: (Alice: 50) &lt;--
(D005F27FE4)”，即使用哈希值为“D005F27FE4”的交易作为输入，转账50给Alice，整体交易的哈希值为“95280182E2”，该哈希值即可一次性的被用作下次交易的输入；

下面是区块的打印代码片段

  -----------------------------------------------------------------------------------------------------------------------------
  1.  **protected** **override** **string** DebuggerDisplay =&gt; \$"{this.Hash.ToShort()}" +  
  
  2.      \$": (" +  
  
  3.      \$"N: {this.Nonce,8}" +  
  
  4.      \$", " +  
  
  5.      \$"T: {this.Transactions.Length}" +  
  
  6.      \$")\\r\\n" +  
  
  7.      \$"  {string.Join&lt;Transaction&gt;(Environment.NewLine + "  ", this.Transactions ?? new Transaction\[\] { })}";  
  
  -----------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\Block.cs

其中，

-   第1行：打印简短版的哈希值；

-   第3行：打印该区块的随机数值，并以最长8位数右对齐；

-   第5行：打印该区块中的交易数量；

-   第6-7行：在下一行后面，每一行打印一个交易的详情（交易详情输出的样例见前一个代码片段）；

最终整体打印出的结果类似于：“0000A98510: (N: 71081, T:
0)”，即该区块的哈希值为“0000A98510”，使得该区块有效的随机数为71081，该区块的交易数量为0；

最终，综合以上的所有代码，我们尝试执行程序，执行结果如下：

  -------------------------------------------------------------------
  Press any key to stop....
  
  Genesis Block: 0000A98510: (N: 71081, T: 0)
  
  New block created at height\[0002\]: 00009782C2: (N: 4207, T: 1)
  
  1D3745CF49: (Icer(Miner): 50) &lt;-- (Coin Base)
  
  New block created at height\[0003\]: 00000CE915: (N: 16355, T: 1)
  
  D1075ABCBC: (Icer(Miner): 50) &lt;-- (Coin Base)
  
  New block created at height\[0004\]: 00004B58D1: (N: 16033, T: 1)
  
  E44FADFD81: (Icer(Miner): 50) &lt;-- (Coin Base)
  
  New block created at height\[0005\]: 000013D191: (N: 7177, T: 1)
  
  6271D89EF7: (Icer(Miner): 50) &lt;-- (Coin Base)
  
  ……
  -------------------------------------------------------------------

从结果中我们看出：

-   区块在持续性的产生；

-   区块的哈希值符合了我们的难度定义；

-   每一个区块为了使得哈希值符合难度定义，均找到了一个使区块有效的不同的随机数；

-   因为我们没有定义任何额外的交易，所以除了创世区块之外，每个区块都仅有一笔CoinBase交易；

-   区块的高度是递增的；

-   CoinBase交易的受益者（接收者）为我们定义的用户；

-   不管是交易还是区块，都不会有重复的哈希值；

#### 基本练习二 发送交易

基于前面基本练习一，试着发送转账交易。

这里，先添加一个简化程序的方法（及其重载）。

  ------------------------------------------------------------------------------------------------------------------------------
  1.  **private** **static** **void** SendMoney(Engine engine, Transaction utxo, **string** receiver, **int** value)    
  
  2.  {    
  
  3.      SendMoney(engine, utxo, **new** TransactionOutput { Owner = receiver, Value = value });    
  
  4.  }    
  
  5.  **private** **static** **void** SendMoney(Engine engine, Transaction utxo, **params** TransactionOutput\[\] outputs)    
  
  6.  {    
  
  7.      engine.AttachTransaction(**new** Transaction    
  
  8.      {    
  
  9.          InputTransactions = **new**\[\] { utxo.Hash },    
  
  10.         OutputOwners = outputs,    
  
  11.     });    
  
  12. }    
  
  ------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Program.cs

其中，

-   第1-4行：发送一笔转账交易的重载版本，仅支持一位接收者；

-   第5-12行：发送一笔转账交易的完整版本，支持任意数量的接收者；

继而在新区块创建成功的事件里面添加以下代码，分别在高度为2或者3的时候执行转账操作。

  ---------------------------------------------------------------------------------------------------
  1.  **private** **static** **void** Engine\_OnNewBlockCreated(**object** sender, Block block)    
  
  2.  {    
  
  3.      ...  
  
  4.    
  
  5.      **if** (height == 2)    
  
  6.      {    
  
  7.          var utxo = engine.BlockChain.Tail.Transactions.First();    
  
  8.          SendMoney(engine, utxo, AliceName, 50);    
  
  9.      }    
  
  10.     **else** **if** (height == 3)    
  
  11.     {    
  
  12.         var utxo = engine.BlockChain.Tail.Transactions    
  
  13.             .First(txs =&gt; txs.OutputOwners.Any(\_ =&gt; \_.Owner == AliceName));    
  
  14.         SendMoney(engine, utxo, BobName, 50);    
  
  15.     }    
  
  16. }    
  
  ---------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Program.cs

其中，

-   第5-9行：当区块的高度为2时，即创世区块后一个正常的区块被挖出来后，这时矿工刚好收到了第一笔奖励，于是在该区块中找到这笔奖励的交易，并使用该交易执行向Alice发起价值50的转账交易；

-   第10-15行：当区块的高度为3时，即上一步骤中发送给Alice的转账交易已经顺利完成的时候，我们在前一区块中找到属于Alice的未使用交易，并使用该交易执行向Bob发起价值50的转账交易；

综合以上代码执行之后，结果如下：

  -------------------------------------------------------------------
  Press any key to stop....
  
  Genesis Block: 0000A98510: (N: 71081, T: 0)
  
  New block created at height\[0002\]: 00006B5C84: (N: 3352, T: 1)
  
  D005F27FE4: (Icer(Miner): 50) &lt;-- (Coin Base)
  
  New block created at height\[0003\]: 0000181DE3: (N: 6573, T: 2)
  
  3E95C5F823: (Icer(Miner): 50) &lt;-- (Coin Base)
  
  95280182E2: (Alice: 50) &lt;-- (D005F27FE4)
  
  New block created at height\[0004\]: 00002F3A57: (N: 16850, T: 2)
  
  C09C1ECB6D: (Icer(Miner): 50) &lt;-- (Coin Base)
  
  B1A4A1FE64: (Bob: 50) &lt;-- (95280182E2)
  
  New block created at height\[0005\]: 00001861AF: (N: 45519, T: 1)
  
  3B19760348: (Icer(Miner): 50) &lt;-- (Coin Base)
  
  ……
  -------------------------------------------------------------------

从结果中我们看出：

-   前面一个基本练习中的大部分特点依旧在此成立；

-   高度为3的区块中包含了2笔交易，除了CoinBase交易之外，还有我们定义的交易，其使用高度为2的区块中哈希值为“D005F27FE4”的CoinBase交易作为输入，转账50给Alice；

-   高度为4的区块中包含了2笔交易，除了CoinBase交易之外，还有我们定义的交易，其使用高度为3的区块中哈希值为“95280182E2”的转账交易作为输入，从Alice转账50给Bob；

#### 基本练习三 添加无效交易

在这个练习中，需要添加一个无效的交易，并观察其被忽略的过程。

基于前一个基本练习，代码的改动如下：

  -------------------------------------------------------------------------------------------------
  1.  **private** **static** Transaction h2utxo = **null**;  
  
  2.  **private** **static** **void** Engine\_OnNewBlockCreated(**object** sender, Block block)  
  
  3.  {  
  
  4.      ...  
  
  5.      **if** (height == 2)  
  
  6.      {  
  
  7.          ...  
  
  8.          h2utxo = utxo;  
  
  9.      }  
  
  10.     ...  
  
  11.     **else** **if** (height == 4)  
  
  12.     {  
  
  13.         SendMoney(engine, h2utxo, BobName, 50);  
  
  14.     }  
  
  15. }  
  
  -------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Program.cs

其中，

-   第1行：声明一个静态变量，用来临时存放高度为2时用过的交易；

-   第8行：在高度为2的代码片段内，将当时用的交易存储到临时变量中去；

-   第11-14行：当高度为4时，即前面Alice已经完成了转账50给Bob之后，我们尝试使用已经使用过的交易再次发起转账请求；

运行起来的输出和基本练习二的完全一样，说明最后一笔转账请求被认为是无效交易而被忽略，没有被打包进新的区块。

#### 扩展练习一 动态难度

本章代码使用了固定的难度系数来生成有效的区块，但实际使用中，可能会由于算力的不断提升，使得初期定义的较低难度无法匹配当前网络中的算力。

请在本章代码的基础上增加类似于比特币中的动态难度机制。

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  扩展知识
  
  随着比特币的升值，挖矿显得越来越有价值，因此挖矿的设备也不断的在升级。
  
  **CPU挖矿**：最早的比特币客户端都是允许用户用他们自己的电脑CPU挖矿的，但随着使用GPU挖矿时代的到来，CPU挖矿显得非常不经济，因为在同等的电力消耗情况下，GPU的挖矿速度和能力远远超过CPU。因此，比特币的客户端将CPU挖矿这个选项去掉了。
  
  **GPU挖矿**：比起CPU挖矿来说，GPU就显得更快、更有效率。GPU是图形处理单元，是计算机系统中用来做视频处理和渲染的组件，而视频的处理本身就是一大堆重复的工作，即需要针对屏幕上大量的像素点进行相同的操作。因此GPU就被设计成适合做这种大量重复工作的模块，比特币的挖矿其实就是一个不断重复的哈希运算，正好符合了GPU的特性。
  
  **FPGA挖矿**：即便GPU挖矿相比CPU挖矿来说已经非常有效率了，但FPGA将比GPU更高的效率带来了。FPGA在通常情况下，只需要消耗很少的一点点电力，便能得到大量的哈希计算能力。
  
  **ASIC挖矿**：ASIC即应用专用集成芯片，是一种为专门的目的设计和制造出来的微型集成电路。最早的ASIC是在2013年被开发出来用作比特币挖矿的。相比前一代技术，它在速度和效率方面都得到了极大的提升。与此同时，它也使得用GPU挖矿再没有任何经济价值了。
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#### 扩展练习二 让创世区块中包含CoinBase交易

在比特币的创世区块中包含了一笔含有“The Times 03/Jan/2009 Chancellor on
brink of second bailout for
banks”信息的CoinBase交易，这句话是泰晤士报当天的头版文章标题，引用这句话，既是对该区块产生时间的说明，也可视为半开玩笑地提醒人们一个独立的货币制度的重要性，同时告诉人们随着比特币的发展，一场前所未有的世界性货币革命将要发生。该消息是由比特币的创立者中本聪写入创世区块中。

本章代码中的创世区块设计为无交易，请在本章代码的基础上修改为：让创世区块中包含一笔CoinBase交易，并在该交易中包含一句你想要在区块链中永流传的话语。

#### 扩展练习三 让每笔交易拥有交易费

比特币的经济生态设定中非常重要的一点就是交易费用，对于矿工来说，最重要的收入来源是每个区块挖得时的奖励，但该奖励设计为每过四年减半，直到后来非常少，到最终完全没有，当奖励无法激励矿工持续的工作时，尤其是当所有有奖励的比特币区块都挖掘完成时，整个网络的运营就是靠交易费进行维持的。

请在本章程序的基础上创建一些有交易费的交易，并让矿工获得这些交易费。

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  扩展知识
  
  在第124724号区块，一个名为midnightmagic的用户，在其成功挖得的区块中故意少给了自己1聪（等于一亿分之一比特币，“聪”为比特币的最小单位）的奖励，并将该区块中的所有交易费用摧毁，故比特币出产总量也因此略微减少了这1聪。
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

支持轻量客户端
--------------

在上一章中，逐步的编写了一个基本的区块链程序，这个程序可以处理区块链上的所有事务，包括创建区块、验证区块和发起交易，在网络视图中，我们称运行这样的程序的网络节点为全量节点，与其对应的是只存储了少量数据的轻量节点，而在轻量节点上运行的便是受限的轻量客户端。

由于资源的限制，不是所有的设备都可以运行完整的全量节点，例如在手机、平板等只有受限资源的智能设备上，通常是无法存储区块链记录的大量数据，而轻量客户端仅仅需要下载区块头信息，而不用下载包含在每个区块中的交易信息。由此产生的不含交易信息的区块链，大小会远远小于完整的区块链，这样便适合在受限环境上执行。鉴于轻量客户端并不知道网络上所有交易的完整信息，其验证交易时所使用的方法略有不同，这个方法需依赖对等的全节点“按需"提供区块链中相关部分的局部视图。

本章内容便顺着实现轻量客户端的思路，分别讲了用于比特币的非对称加密算法中的椭圆曲线算法，用。。。。。。。

### 数字签名

在第一章，我们已经初步了解了如何使用密码学中的非对称加密算法来做数字签名，在本章中会重点讲解被用在比特币中的椭圆曲线密码学。

#### 椭圆曲线密码学

椭圆曲线可以在平面域中用 $y^{2} = x^{3} + ax + b$ 描述，例如当a=-3,
b=3时，即$y^{2} = x^{3} - 3x + 3$的曲线如下图a所示。

定义一种在此曲线上的加法，即选择任意非对称的两个点，连接这两个点，并使得延长线与该曲线相交，该交点在x轴的对称点即为该加法的结果，如下图b所示，我们选取了a和b两个点，连接并取其延长线与曲线的交点的对称点为其结果a+b。

  ![](media/image45.png){width="1.811023622047244in" height="1.811023622047244in"}   ![](media/image47.png){width="1.811023622047244in" height="1.811023622047244in"}
  ---------------------------------------------------------------------------------- ----------------------------------------------------------------------------------
  a                                                                                  b

若使b=a，计算a+b即为计算2a，而连接两个点的连接线因为两个点是在同一位置而成为该点的切线，如下图c所示，通过a点的切线与曲线相交，并取该交点的对称点为2a。重复该过程，可以得到如下图d中的4a。若需要计算的结果并非2的幂次，可以通过加法的方法进行计算，如下图e，我们要计算6a则只需要计算4a+2a，4a和2a已经在下图c和下图d中计算出来，使用曲线上加法的基本定义，连接4a和2a两个点，延长并与曲线相交，取该交点的对称点为6a。

  ![](media/image49.png){width="1.811023622047244in" height="1.811023622047244in"}   ![](media/image51.png){width="1.811023622047244in" height="1.811023622047244in"}   ![](media/image53.png){width="1.813186789151356in" height="1.813186789151356in"}
  ---------------------------------------------------------------------------------- ---------------------------------------------------------------------------------- ----------------------------------------------------------------------------------
  c                                                                                  d                                                                                  e

因此，当需要计算na时，应将n分解成多个2的不同幂次的和的形式，例如当n=12345时，可以分解成：$n = 2^{13} + 2^{12} + 2^{5} + 2^{4} + 2^{3} + 2^{0}$，因此计算该数字总共需要的加法计算次数=最大幂次+分解加法次数=13+5=18。由此可以看出，即便当数字非常大的时候，计算的次数也不会发生非常大的变化。

在椭圆曲线密码学中，作为公共基础的信息有以下几项：

-   曲线参数a和b，即椭圆曲线$y^{2} = x^{3} + ax + b$的参数；

-   基础点G，即我们选取的曲线上的初始点，如上图c中的a点；

-   有限域Fp，即结果可以处于的有限数范围\*；

-   基于基础点G的阶数n，即处于该有限域上可能的点的个数\*\*；

-   阶数n的协因子(cofactor)\*\*；

注\*：对于有限域的理解，大可不必恐慌，其概念其实非常简单，即根据计算机的特点设计出来可由计算机表示的有限的数字范围，与实数域不同的是，在有限域中并不可以表示任意数字，而且有最大值，所有超过这个最大值的数字都会经过一定的方法回到这个有限域中。而椭圆曲线在有限域的样子大概如下图：（虽是离散点，但其对称性依旧保留下来了）

![](media/image55.png){width="2.7153182414698165in"
height="1.6782174103237095in"}

注\*\*：通常通过一定量的计算后，某一个数值n会使得nG=0，即该点的切线不与曲线上其他任一点相交，而比特币所使用的secp256k1中的n是素数，即不可被因式分解，故其协因子为1。

#### 数字签名

在此继续使用第一章使用过的示例，仍旧是Alice要发送消息给Bob，需要对她发送的消息进行签名，以防止Eve篡改伪造。

  ---------------------------------------------------------------------------------------------------------------------------------
  步骤                       只有Alice知道的信息                                 所有人都知道的信息
  -------------------------- --------------------------------------------------- --------------------------------------------------
  定义曲线参数                                                                   曲线参数(Fp,a,b,G,n,h)

  选取一个正实数，即私钥     $$d \in \lbrack 1,\ n - 1\rbrack$$                  

  计算dG的乘积，即公钥       $$\left( Q_{x},Q_{y} \right) = dG$$                 $$\left( Q_{x},Q_{y} \right)$$

  准备发送的消息                                                                 m

  对消息做哈希计算                                                               e=HASH(m)

  选择一个安全的随机数       $$k \in \lbrack 1,\ n - 1\rbrack$$                  

  使用该随机数计算曲线点     $$\left( x_{1},y_{1} \right) = kG$$                 

  对发送的消息签名，并公开   $$r = x_{1}\text{mod\ n}$$                          (r, s)
                                                                                 
                             $$s = k^{- 1}\left( z + rd \right)\text{mod\ n}$$   

  根据已知信息进行验算                                                           $${w = s}^{- 1}\text{mod\ n}$$
                                                                                 
                                                                                 $$u_{1} = zw\ mod\ n,\ u_{2} = rw\ mod\ n$$
                                                                                 
                                                                                 $$\left( x_{1},y_{1} \right) = u_{1}G + u_{2}Q$$

  确认签名                                                                       $$r \equiv x_{1}\text{\ mod\ n}$$
  ---------------------------------------------------------------------------------------------------------------------------------

鉴于椭圆曲线算法本身已经不是直接按计算器就能算出来的算法了，故部分读者可能无法从上述过程中看到为何Eve很难伪造签名，这里举个通俗的例子来说明，如下图，我们知道曲线的基本参数，然后Eve只能知道Alice公布的她的公钥Q点，这个是无法逆转知道dG=Q，对于Eve来说，想要知道私钥d的唯一可能就是从1开始枚举所有可能的数字，使得dG=Q，这时候Alice的私钥d便被破解了，但若d的数字非常大，以现在的计算机能力可能会是耗费非常久的时间都无法计算出来；而对于验证签名，却非常简单，只要将Alice提供的数字带入到曲线中去做非常有限次的计算便可以验证其正确性。

![](media/image57.png){width="2.1875in" height="2.1875in"}

注意一：本段解释尽量使用通俗的文字让无充分学术背景的读者也可以轻松的理解，故部分概念做了简化处理，若需要做学术研究，请另行参考密码学读物。

注意二：比特币所使用的secp256k1曲线，并未采用其他曲线常采用的二进制有限域$GF(2^{n})$。

  ------------------------------------------------------------------------------------------------------------------------------------
  扩展知识
  
  2010年12月，一群自称failOverflow的黑客，通过PS3上的程序漏洞获得了使用椭圆曲线算法签名的私钥，至此也就宣告PS3被彻底成功破解。
  
  而这个程序漏洞就是由于在使用椭圆曲线算法进行签名时，使用了不安全的随机数——一个固定值，使得签名中r始终相同，黑客由此反推出了私钥Q。
  ------------------------------------------------------------------------------------------------------------------------------------

#### 引用第三方组件

本章中已经详细的讲解了椭圆曲线密码学，但是我们并不准备在代码上去实现和讲解一次，学习密码学的细节是为了让开发者在编写代码时能更加谨慎，避免由于代码错误带来的灾难。

非对称密码学，在签名和加密领域都是非常重要的，而以密码学为基础的区块链，其重要程度决不可小觑，在该领域发生的许多安全事件均是由于代码编写错误导致的，通过详细理解其数学基础，并良好的编写对应代码才可以避免灾难一般的后果。

本节中会引用第三方组件，一方面是可以免去密码学冗长的实现细节，另一方面该组件也融合了网上两种不同的开源实现，以到达功能和效率的平衡。

首先我们通过程序包管理器控制台（在VS中参照下图），安装该组件。

![](media/image59.png){width="4.9603958880139984in"
height="1.5784722222222223in"}

可在程序包管理器控制台键入以下命令：

PM&gt; Install-Package UChainDB.ChainEngine.Cryptography.EcDsa.Secp256k1

命令完成后，再查看工程时，可在依赖项下面看到该第三方组件的存在：

![图片包含 屏幕截图
已生成高可信度的说明](media/image60.tmp){width="3.7178215223097113in"
height="1.0032228783902013in"}

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  扩展知识
  
  **什么是NuGet？**
  
  NuGet（读作New Get）是用于微软.NET开发平台的软件包管理器，是一个Visual Studio的扩展。在使用Visual Studio开发基于.NET Framework的应用时，NuGet能够令你在项目中添加、移除和更新引用的工作变得更加快捷方便。
  
  通过NuGet你可以很容易的访问到其他开发者发布的软件包，你也可以创建、分享或者发布自己的包到NuGet。微软的EntityFramework、ASP.NET MVC等或者一些常用到的第三方软件包：Json.NET、NUnit等都托管到NuGet上。
  
  **为什么要用NuGet？**
  
  上面说道NuGet实际上就是一个软件包的托管平台。一个大的项目不可能所有的功能都要自己去实现，有句话说的好：“不要轻易造轮子”，最简单直接的办法就是使用别人造好的“轮子”。通常引用一个类库到我们的项目中要先下载或找到类库，然后复制到项目目录，最后添加引用。
  
  如果我们引用的类库有更新的版本并且我们想使用的话又要重新添加引用，一两个倒还好，如果引用数量较多的话重复添加引用是比较麻烦和枯燥的，并且要卸载引用的时候还是要经过几个步骤。
  
  这也就是为什么推荐使用NuGet的原因，NuGet能够让我们轻松的实现对软件包的引用、更新和卸载。
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#### 密码学实体强类型

使用C++、Java、C\#等类的高级语言的一大特点就是强类型，使得很多错误可以在编译时就发现，本章中私钥、公钥、签名等信息均是以字节数组的形式存储在计算机内存中的，但若直接使用字节数组作为各种方法的输入输出参数，难免会出现传入了错误的参数，或者将传出的参数误用的情况，如以下代码中，两行代码是同一功能的接口定义：

  -------------------------------------------------------------------------------------------
  1.  **byte**\[\] Sign(IEnumerable&lt;**byte**\[\]&gt; data, **byte**\[\] privateKey);    
  
  2.  Signature Sign(IEnumerable&lt;**byte**\[\]&gt; data, PrivateKey privateKey);    
  
  -------------------------------------------------------------------------------------------

第二行中因为使用Signature和PrivateKey实体类型，使得传入参数时可以做类型检查，避免出错，而第一行中的接口，我们甚至无法在不查阅文档的情况下知道其返回的究竟是什么。

综上所述，我们需要定义密码学实体的强类型。

首先我们定义字节数组长度的定义类。

  ---------------------------------------------------------------
  1.  **public** **abstract** **class** ByteArrayDef  
  
  2.  {  
  
  3.      **public** **abstract** **int** Length { **get**; }  
  
  4.  }  
  
  ---------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\ByteArray.cs

其中，

-   第3行，我们使用抽象类中的抽象属性，使得实现该抽象类的具体类可以给出具体值，而该值的含义即是字节数组的固定长度，以方便我们做运行时检查。

以下的字节数组类ByteArray&lt;T&gt;，使用了刚才定义的字节数组定义类作为泛型的输入，以便在基类中对该类型的字节长度进行运行时检查。（非关键代码被隐藏，请查阅配套代码查看完整示例）

  -------------------------------------------------------------------------------------------------------------------
  1.  **public** **abstract** **class** ByteArray&lt;T&gt; where T : ByteArrayDef, **new**()  
  
  2.  {  
  
  3.      **protected** **readonly** **byte**\[\] bytes;  
  
  4.      **protected** **readonly** T Def = **new** T();  
  
  5.    
  
  6.      **public** ByteArray(**byte**\[\] byteArray)  
  
  7.      {  
  
  8.          **if** (byteArray.Length != **this**.Def.Length)  
  
  9.          {  
  
  10.             **throw** **new** ArgumentException(\$"Length should be {this.Def.Length}", nameof(byteArray));  
  
  11.         }  
  
  12.   
  
  13.         **this**.bytes = byteArray;  
  
  14.     }  
  
  15.   
  
  16.     **public** **static** **implicit** **operator** **byte**\[\] (ByteArray&lt;T&gt; obj)  
  
  17.     **public** **string** ToBase58()  
  
  18.     **public** **static** **bool** **operator** ==(ByteArray&lt;T&gt; left, ByteArray&lt;T&gt; right)  
  
  19.     **public** **static** **bool** **operator** !=(ByteArray&lt;T&gt; left, ByteArray&lt;T&gt; right)  
  
  20.     **public** **override** **bool** Equals(**object** obj)  
  
  21.     **public** **override** **int** GetHashCode()  
  
  22. }  
  
  -------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\ByteArray.cs

其中，

-   第3行，内部实际存储的字节数组；

-   第4行，字节数组定义类，并在类型初始化时进行实例化；

-   第6行，字节数组类的构造函数，输入真正的字节数组，在内部对其封装；

-   第8-11行，根据字节数组定义类中指定的字节数组长度，对输入的参数进行运行时检查，若长度不为预定值时，抛出异常；

-   第13行，将符合标准的字节数组赋值在内部存储中；

-   第16行，鉴于本类究其本质就是字节数组，故此处申明可隐式转换成系统中的字节数组，以方便操作；

-   第17行，将该字节数组以Base58的形式输出，关于Base58的内容请参阅后续章节；

-   第18-21行，重载相等、不等操作符，方便比较两个字节数组的内容是否一致，即可比较签名、私钥、公钥等是否是相同的；

以上我们定义基本的字节数组抽象类的主要目的，还是为我们后续定义真正被使用的签名、私钥、公钥等类时，可以减少重复的代码。

以下是签名类的定义类。

  ------------------------------------------------------------
  1.  **public** **class** SignatureDef : ByteArrayDef  
  
  2.  {  
  
  3.      **public** **override** **int** Length =&gt; 64;  
  
  4.  }  
  
  ------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\Signature.cs

其中，

-   第3行，定义了签名的字节数组的长度为64；

以下是签名实体类，即在程序中被广泛引用的类型。

  --------------------------------------------------------------------------------
  1.  **public** **class** Signature : ByteArray&lt;SignatureDef&gt;  
  
  2.  {  
  
  3.      **public** Signature(**byte**\[\] byteArray)  
  
  4.          : **base**(byteArray)  
  
  5.      {  
  
  6.      }  
  
  7.    
  
  8.      **public** **static** Signature ParseBase58(**string** base58String)  
  
  9.      {  
  
  10.         **return** **new** Signature(Base58.Decode(base58String));  
  
  11.     }  
  
  12. }  
  
  --------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\Signature.cs

其中，

-   第3-6行，签名类的构造函数，将传入的字节数组传入基类进行初始化；

-   第8-11行，将Base58的字符串解析成签名类；

除此之外，存储地址的Address类，存储私钥的PrivateKey类，存储公钥的PublicKey类都与该签名类基本类似，在这里就不把代码一一进行讲解了。

#### 包装密码学类

在此我们稍微考虑一点扩展性，定义一个基础的签名算法接口，以方便未来更换不同的密码学算法。

  ------------------------------------------------------------------------------------------------------
  1.  **public** **interface** ISignAlgorithm  
  
  2.  {  
  
  3.      Signature Sign(IEnumerable&lt;**byte**\[\]&gt; data, PrivateKey privateKey);  
  
  4.      **bool** Verify(IEnumerable&lt;**byte**\[\]&gt; data, PublicKey publicKey, Signature sig);  
  
  5.      PublicKey GetPublicKey(PrivateKey privateKey);  
  
  6.      PrivateKey GenerateRandomPrivateKey(**long** random =0);  
  
  7.  }  
  
  ------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Utility\\ISignAlgorithm.cs

其中，

-   第3行，创建签名接口，输入数据及私钥，输出签名；

-   第4行，验证签名接口，输入数据及公钥和签名，输出签名是否有效；

-   第5行，根据私钥计算出对应的私钥；

-   第6行，根据随机数的种子值计算随机的私钥；

在这里是这个签名算法接口的一个实现——关于椭圆曲线算法的实现，这里先介绍该类中的成员，接口实现在后面依次讲解。

  -------------------------------------------------------------------------------
  1.  **using** UChainDB.BingChain.Engine.Cryptography;  
  
  2.    
  
  3.  **public** **class** ECDsaSignAlgorithm : ISignAlgorithm  
  
  4.  {  
  
  5.      **internal** **readonly** Secp256k1 signAlgo = **new** Secp256k1();  
  
  6.  }  
  
  -------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Utility\\ECDsaSignAlgorithm.cs

其中，

-   第1行，首先需要引用通过nuget引入的第三方组件的命名空间；

-   第5行，在内部实例化一份该第三方组件的实例；

以下是根据随机数的种子计算随机的私钥的实现，不过此处为展示目的，故并未实现“根据种子数”这一过程，而是直接通过随机生成的。一个安全且良好的随机数实现是很复杂的，故本章节不做深入讲解。

  ---------------------------------------------------------------------------------------------
  1.  **public** PrivateKey GenerateRandomPrivateKey(**long** random = 0)  
  
  2.  {  
  
  3.      var privateKey = **new** **byte**\[32\];  
  
  4.      **using** (var rng = System.Security.Cryptography.RandomNumberGenerator.Create())  
  
  5.      {  
  
  6.          rng.GetBytes(privateKey);  
  
  7.      }  
  
  8.    
  
  9.      **return** **new** PrivateKey(privateKey);  
  
  10. }  
  
  ---------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Utility\\ECDsaSignAlgorithm.cs

其中，

-   第3行，先初始化私钥的存储空间；

-   第4行，初始化.Net框架提供的随机数生成器；

-   第6行，使用该随机数生成器生成随机数并填充到实现准备的私钥变量中；

-   第9行，将该私钥的字节数组类型转换成私钥实体类型后返回；

以下方法根据私钥生成公钥。

  ----------------------------------------------------------------------------
  1.  **public** PublicKey GetPublicKey(PrivateKey privateKey)  
  
  2.  {  
  
  3.      var publicKey = **this**.signAlgo.SelectedCurve.G \* privateKey;  
  
  4.      **return** **new** PublicKey(publicKey.EncodePoint(**true**));  
  
  5.  }  
  
  ----------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Utility\\ECDsaSignAlgorithm.cs

其中，

-   第3行，根据椭圆曲线的公钥生成方法，将曲线的基础点G与私钥相乘即可获得，其返回值为坐标点(x,y)；

-   第4行，将坐标点压缩存储，对应将其转换成公钥实体类型；

在前面的学习中已经知道公钥其实就是在曲线上的一个坐标点，即为(x,y)，两个坐标点均为32字节即256位的数字，存储空间为64字节，不过可以只存储x坐标，通过椭圆曲线方程的计算，便可以获得y值，但是因为椭圆曲线是沿x轴对称的，因此还需要存储该坐标点是否在x轴上方，故最终压缩存储的公钥占33个字节，在系统内传递的均为此压缩编码的公钥。

以下方法直接调用第三方组件进行签名创建。

  ----------------------------------------------------------------------------------------------
  1.  **public** Signature Sign(IEnumerable&lt;**byte**\[\]&gt; data, PrivateKey privateKey)  
  
  2.  {  
  
  3.      **return** **new** Signature(**this**.signAlgo.Sign(privateKey, data));  
  
  4.  }  
  
  ----------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Utility\\ECDsaSignAlgorithm.cs

其中，

-   第3行，直接调用第三方组件中的签名算法，使用传入的私钥对传入的信息进行签名，并返回签名信息；

以下方法直接调用第三方组件进行签名验证。

  ------------------------------------------------------------------------------------------------------------
  1.  **public** **bool** Verify(IEnumerable&lt;**byte**\[\]&gt; data, PublicKey publicKey, Signature sig)  
  
  2.  {  
  
  3.      **return** **this**.signAlgo.Verify(publicKey, sig, data);  
  
  4.  }  
  
  ------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Utility\\ECDsaSignAlgorithm.cs

其中，

-   第3行，直接调用第三方组件中的签名验证算法，对传入信息比照传入的公钥和签名进行验证，并以布尔值的形式返回出去；

### 哈希树

在密码学及计算机科学中，哈希树（hash
tree）是一种树形数据结构，每个叶节点均以数据块的哈希作为标签，而除了叶节点以外的节点则以其子节点标签的哈希结果作为标签。哈希树能够高效、安全地验证大型数据结构的内容。哈希树的概念由拉尔夫·默克尔（Ralph
Merkle）于 1979 年申请专利，故亦称默克尔树（Merkle
Tree）。也常用在对等网络中，用于验证在计算机之间的存储、处理和传输的数据，以确保其从对等网络中接受到的数据未受损或被修改，甚至可以检查数据是否受到篡改。

#### 基础

在比特币的区块头中，便包含有默克尔根（Merkle
Root）这一元素，该元素的值便是选取的如下图所示的哈希树的根节点。

比特币中的哈希树有以下特点：

-   它是数据结构意义上的一种树，且是二叉树，即每个节点最多两个子节点；

-   每个节点均以哈希值输出，其哈希值的计算来源于其子节点的值；

-   只有叶子节点才是一笔交易的哈希值；

-   任意叶子节点的哈希值改变，均会导致根节点的哈希值改变，因此可被用作高效、安全地验证大型数据内容的一种数据结构；

-   验证一笔交易是否存在于该哈希树中，只需要树高度（即从叶子节点到根节点的节点数目）加一个节点的哈希值即可，且因为树高度呈对数增长（即增长缓慢），一个拥有10万节点的哈希树，高度也只有17，故只需少量数据便可验证一笔交易是否存在于该哈希树中，具体实现会在下一节中详解；

以下是节点的基本定义（既可能是叶子节点，也可能是根节点或中间的任意节点）。

  --------------------------------------------------------
  1.  **internal** **class** MerkleTreeNode  
  
  2.  {  
  
  3.      **public** MerkleTreeNode(UInt256 hash)  
  
  4.      {  
  
  5.          **this**.Hash = hash;  
  
  6.      }  
  
  7.    
  
  8.      **public** UInt256 Hash { **get**; }  
  
  9.      **public** MerkleTreeNode Left { **get**; }  
  
  10.     **public** MerkleTreeNode Right { **get**; }  
  
  11.  }  
  
  --------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTreeNode.cs

其中，

-   第3-6行，以哈希值初始化节点，节点存储的核心数据就是这个哈希值；

-   第8行，哈希值的内部存储属性；

-   第9-10行，该节点的左右节点，对于叶子节点，该两个属性应为空；

#### 创建哈希树

先通过一个示例来模拟哈希树的创建过程，如下图左。

-   第一步，准备所有叶子节点数据，如图所示，假设该区块中有TxA、TxB、TxC、TxD四个交易，分别计算每个交易的哈希值，并将对应的哈希值H~A~、H~B~、H~C~、H~D~填入叶子节点；

-   第二步，将叶子节点两两成对作为左右节点，并产生对应的父节点，如图所示，分别以H~A~、H~B~、H~C~、H~D~作为基础，计算出对应的父节点哈希值H~AB~、H~CD~并填入该节点；

-   第三步，将第二步反复执行，直到仅剩下一个节点为止；

-   第四步，最后仅剩下的唯一节点，便是哈希树的根节点，将其哈希值填入区块头，作为区块链验证数据正确性的证明材料，如图所示，最终我们获得了根节点H~ABCD~；

  -- --
     
  -- --

若区块中交易数量恰好无法使得哈希树达到满二叉树（即除最后一层叶子节点无任何子节点外，每一层上的每个节点均有两个子节点的二叉树），可以通过将最后一个交易复制多次的方式补足二叉树，如上图右所示，在仅有三个交易的情况下，TxC被重复的出现在最后两个叶子节点中。

为了后续更加容易的构建树形结构，我们对节点类进行功能扩展，扩展一个新的构造函数和父节点的引用，方便做回溯操作。

  ------------------------------------------------------------------------------------------------------------------
  1.  **internal** **class** MerkleTreeNode  
  
  2.  {  
  
  3.      **public** MerkleTreeNode(MerkleTreeNode left, MerkleTreeNode right, MerkleTreeNode parent = **null**)  
  
  4.      {  
  
  5.          **this**.Left = left;  
  
  6.          **this**.Left.Parent = **this**;  
  
  7.          **this**.Right = right;  
  
  8.          **if** (**this**.Right != **null**) **this**.Right.Parent = **this**;  
  
  9.          **this**.Parent = parent;  
  
  10.         **this**.Hash = **new** Hash(**new** **byte**\[\]\[\] { left.Hash, (right ?? left).Hash });  
  
  11.     }  
  
  12.     **public** MerkleTreeNode Parent { **get**; **private** **set**; }  
  
  13. }  
  
  ------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTreeNode.cs

其中，

-   第3-9行，通过已经构建完成的左右节点和可选的父节点组成新的节点，并且为左右子节点设置其父节点属性；

-   第10行，通过左右节点的哈希值，算出该节点的哈希值，并在右节点为空时，使用左节点代替计算哈希值，当哈希树无法达到满二叉树的时候，该情况便会出现；

-   第12行，父节点的属性；

以下是创建哈希树的方法，注意该代码是递归执行，其执行顺序如下图所示，递归层数和节点数目应根据实际传入的节点数目有所变化，下图为节点数为4时的情况。

  --------------------------------------------------------------------------------------------
  1.  **private** **static** MerkleTreeNode BuildTree(MerkleTreeNode\[\] leaves)  
  
  2.  {  
  
  3.      **if** (leaves.Length == 1) **return** leaves\[0\];  
  
  4.      var parentNumber = (leaves.Length + 1) / 2;  
  
  5.      var parents = **new** MerkleTreeNode\[parentNumber\];  
  
  6.      **for** (**int** i = 0; i &lt; parents.Length; i++)  
  
  7.      {  
  
  8.          var left = leaves\[i \* 2\];  
  
  9.          var right = i \* 2 + 1 &lt; leaves.Length ? leaves\[i \* 2 + 1\] : **null**;  
  
  10.         parents\[i\] = **new** MerkleTreeNode(left, right);  
  
  11.     }  
  
  12.   
  
  13.     **return** BuildTree(parents);  
  
  14. }  
  
  --------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTree.cs

其中，

-   第1行，该方法通过输入一系列的仅含有哈希值的叶子节点，输出构造完成的哈希树的根节点，可以根据后续处理需求，对该树进行遍历、取根哈希或剪枝以备检验；

-   第3行，当仅有一个节点时，直接返回该节点，无需继续创建子树；

-   第4行，计算该层节点的父节点的数目，计算方法：$= \left\lceil /2 \right\rceil$，代码中使用代码技巧避免了Math.Ceiling函数的调用；

-   第5行，初始化父节点数组；

-   第6行，以父节点为依据进行遍历；

-   第8行，从叶子节点中选出适合该父节点的左子节点；

-   第9行，当右子节点存在时赋值，否则设为空；

-   第10行，根据左右子节点构造出父节点，其哈希值会在该类的构造函数中自动根据左右子节点的哈希值进行计算；

-   第13行，进入下一轮的递归，将本层的父节点作为下一层的子节点重复以上过程；

以下是哈希树类，用来装载与哈希树相关的运算和信息。该类会在本节后续部分不断根据功能被扩充。

  ------------------------------------------------------------------------------------------------------
  1.  **public** **class** MerkleTree  
  
  2.  {  
  
  3.      **private** MerkleTreeNode root;  
  
  4.      **public** MerkleTree(UInt256\[\] hashes)  
  
  5.      {  
  
  6.          **this**.root = BuildTree(hashes.Select(p =&gt; **new** MerkleTreeNode(p)).ToArray());  
  
  7.      }  
  
  8.  }  
  
  ------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTree.cs

其中，

-   第3行，存储哈希树的根节点；

-   第4-7行，哈希树的构造函数，输入一系列的哈希值，这些哈希值应该是由交易信息计算产生的；

-   第6行，使用前面才介绍过的创建哈希树的方法，将输入的哈希值构造一颗哈希树，并将其根节点存下；

### 简单交易验证（SPV）

在第一章已经学习过轻量客户端的概念，并知道了并非所有的节点都有能力储存完整的区块链，因此对于这些被设计成运行在空间和功率受限的设备的轻量客户端，通过简单交易验证(SPV)的方式可以使它们在不必存储完整区块链的情况下进行工作。

#### 为什么需要

在配备SPV的轻量客户端中，不再需要下载所有的区块信息，只需要下载区块头信息，对于比特币来说，每个区块只有80字节的区块头，因此每年无论有多少交易，大概都是4.2M字节的区块头信息。因为信息量被控制，于是可以被部署至资源受限的设备中。

区块头中已经包含区块中所有交易组成的哈希树的根信息，若需要验证某笔交易，只要把该笔交易的查询请求发送给与该轻量客户端相连的全节点即可。

#### 安全性考虑

轻量客户端因为没有完整的区块信息，所以无法保证完全安全，但绝大数情况，我们并不用担心其安全性，以下重点讲解两种轻量客户端的安全问题。

第一，通过SPV功能，即便是轻量客户端的信息并不充足，也无法轻易的误以为一笔不存在的交易存在于某个区块中，但是反过来并不成立：轻量客户端向全节点请求一笔交易的信息，但全节点可以隐瞒信息，将实际存在的交易告知轻量客户端不存在。换言之，一笔不存在的交易，轻量客户端绝对有信心可以辨认出来，并不会错把它当作存在的交易，但是一笔实际存在的交易，轻量客户端却没办法确认其存在，即有可能以为该交易尚不存在。

对于该问题的一种解决方法，就是连接上足够多的全节点，并向每个节点发起同样的请求。但如果遇到女巫攻击（一个恶意节点可以伪装成很多节点），轻量客户端可能会轻信多个伪装节点的回复信息。

第二，鉴于轻量客户端总是向全节点请求其感兴趣的信息，通常都是其自己所拥有的账户，这会导致全节点可以轻易的了解用户的全貌（通过类似于同一IP对应哪些账户ID来进行），进一步导致隐私的泄漏。而且全节点可能会策略性的屏蔽部分用户或账户。当然轻量客户端也可以选择发送许多假请求来误导全节点，但这也会导致浪费了大量的带宽资源。

对于该问题的解决，比特币设计了Bloom过滤器，可以混淆请求，在有限的资源内，可以有效的降低全节点识别客户端的风险。该功能将会在高级主题中进行讲解。

该类安全问题主要出自仅实现了SPV功能，无对应防范措施的轻量客户端。

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  扩展知识
  
  为什么叫女巫攻击？
  
  根据Flora Rhea Schreiberie在1973年的小说《女巫》（Sybil）改编的同名电影，是一个化名Sybil Dorsett的女人心理治疗的故事。她被诊断为分离性身份认同障碍，兼具16种人格。
  
  在对等网络中，节点随时可以加入和退出，为了维持网络稳定，一个节点可能会同时连接上指定数量的多个节点。如果网络中存在一个恶意节点，那么同一个恶意节点可以具有多重身份，就如电影了的女主角都可以分裂出16个身份，实际计算机网络中恶意节点能分出更多节点。于是原本期待连接至多个不同节点的那个节点，便被欺骗地连接到了同一个恶意节点（该恶意节点伪装成多重身份），这就是女巫攻击。
  
  如何解决女巫攻击？
  
  1.  三方认证，每一个新加入的节点都需要经过指定的信任三方认证后才能加入。
  
  2.  投票认证，每一个新加入的节点都需要在网的所有节点投票一致通过后才能加入。
  
  3.  工作量证明，即用在比特币网络中使用算力来证明该节点非恶意节点。
  
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#### 增强节点功能

为了使哈希树支持SPV功能，我们需要在上一节实现的哈希树节点类中添加一些辅助属性和方法，使得后续抽取和重建部分哈希树的代码更加精简干练。

以下是对哈希树节点类的增强。

  -----------------------------------------------------------------------------------------------------
  1.  **internal** **class** MerkleTreeNode  
  
  2.  {  
  
  3.      **public** **bool** IsMarked { **get**; **internal** **set**; }  
  
  4.      **public** **bool** IsLeaf =&gt; **this**.Left == **null** && **this**.Right == **null**;  
  
  5.    
  
  6.      **public** IEnumerable&lt;MerkleTreeNode&gt; Ancestors()  
  
  7.      **public** IEnumerable&lt;MerkleTreeNode&gt; EnumerateDescendants()  
  
  8.      **public** IEnumerable&lt;MerkleTreeNode&gt; GetLeafs()  
  
  9.  }  
  
  -----------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTreeNode.cs

其中，

-   第3行，对该节点进行标记，该标记会在抽取部分哈希树的时候用于标记找到交易到根间的所有节点；

-   第4行，当左右子节点同时为空的时候，便说明该节点是叶子节点；

-   第6行，枚举当前节点的所有祖先（该节点的父节点及其父节点，并持续递进下去）节点；

-   第7行，枚举当前节点的所有子孙（该节点的子节点及其子节点，并持续递进下去）节点；

-   第8行，枚举当前节点的所有子孙节点中的叶子节点；

以下是枚举当前节点的所有祖先节点的代码实现。

  ----------------------------------------------------------------
  1.  **public** IEnumerable&lt;MerkleTreeNode&gt; Ancestors()  
  
  2.  {  
  
  3.      var n = Parent;  
  
  4.      **while** (n != **null**)  
  
  5.      {  
  
  6.          yield **return** n;  
  
  7.          n = n.Parent;  
  
  8.      }  
  
  9.  }  
  
  ----------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTreeNode.cs

其中，

-   第3行，将游标初始化为当前节点的父节点；

-   第4行，一直循环到父节点为空为止；

-   第6行，输出游标所在节点；

-   第7行，将游标赋值为其父节点；

以下是枚举当前节点的所有子孙节点的代码实现。

  -----------------------------------------------------------------------------------------------
  1.  **public** IEnumerable&lt;MerkleTreeNode&gt; EnumerateDescendants()  
  
  2.  {  
  
  3.      IEnumerable&lt;MerkleTreeNode&gt; result = **new** MerkleTreeNode\[\] { **this** };  
  
  4.      **if** (Right != **null**)  
  
  5.          result = Right.EnumerateDescendants().Concat(result);  
  
  6.      **if** (Left != **null**)  
  
  7.          result = Left.EnumerateDescendants().Concat(result);  
  
  8.      **return** result;  
  
  9.  }  
  
  -----------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTreeNode.cs

其中，

-   第3行，准备返回用的枚举类型，并将自身放进该枚举，作为最后一个元素，因为后面第5行和第7行均使用Concat语句，将最初放入枚举的内容推迟到最后了；

-   第4-5行，若右节点不为空，则将右节点枚举的子孙放入枚举；

-   第6-7行，若左节点不为空，则将左节点枚举的子孙放入枚举，这句最后执行，故左节点的子孙会优先被返回；

-   第8行，返回这个枚举结果；

以下是枚举当前节点所有子孙节点中的叶子节点。

  ----------------------------------------------------------------------
  1.  **public** IEnumerable&lt;MerkleTreeNode&gt; GetLeafs()  
  
  2.  {  
  
  3.      **return** EnumerateDescendants().Where(l =&gt; l.IsLeaf);  
  
  4.  }  
  
  ----------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTreeNode.cs

其中，

-   第3行，通过枚举所有子孙节点的方法获取所有子孙节点，然后用筛选语句将其中的叶子节点筛选出来；

#### 部分哈希树

轻量客户端验证交易的过程如下图。

![](media/image61.png){width="3.6320745844269466in"
height="2.539212598425197in"}

在轻量客户端向全节点请求交易验证信息后，全节点会根据轻量客户端提供的交易编号，将与该交易有关的区块中的交易哈希树抽取部分哈希树（Partial
Merkle
Tree），借此按照一定算法生成便于客户端重建部分哈希树，并且网络传输友好的信息——哈希数组和标志位，在轻量客户端得到相应的信息后，便进行重建部分哈希树，并根据重建结果验证交易信息。

如下图所示的非空心节点组成的树便是部分哈希树，其中绿色方块表示轻量客户端正在请求的交易节点，蓝色的方块是需要从全节点传回以便在轻量客户端重建部分哈希树所需要的节点，而橙色方块是可由轻量客户端自行计算出来的节点，而且为了验证交易的正确性必须进行计算的节点。

后续内容在描述算法时，对哈希树上的节点进行了简单分类，如下图，在树形结构最下方一排的节点，即直接从交易信息算出哈希值的节点被成为交易节点，除此之外的所有节点均被称之为非交易节点，因为这些节点的哈希值均是通过计算得出的。

虽然从系统运行的顺序看，应该显示抽取部分哈希树，再是重建部分哈希树，但后续章节先讲重建部分哈希树，使得读者可以先感受一下从哈希列表和标志位重建部分哈希树的全过程，为抽取部分哈希树的代码理解打下基础。

#### 重建部分哈希树

要重建部分哈希树，需要至少三个参数：

-   交易数量，用以重建完整哈希树的形状，并明确其高度；

-   哈希列表和标志位，用以正确的重建部分哈希树；

要验证该部分哈希树，需要两个信息：

-   只有区块头信息的区块链，以确保区块呈链状结构，无篡改的可能性；

-   重建完成的部分哈希树，该哈希树根的哈希值应与区块头中的默克尔根一致；

在重建部分哈希树时，会根据收到的标志位进行逐步运算，运算规则如下表所示：

  ----------------------------------------------------------------------------------------------------------------------------------------------------
  标志位   交易节点                                                                   非交易节点
  -------- -------------------------------------------------------------------------- ----------------------------------------------------------------
  0        使用哈希列表中下一个哈希值作为该节点的哈希值，该节点并非请求的交易。       使用哈希列表中下一个哈希值作为该节点的哈希值，不再处理子节点。

  1        使用哈希列表中下一个哈希值作为该节点的哈希值，并且该节点就是请求中交易。   该节点的哈希值需要计算；
                                                                                      
                                                                                      先处理其左子节点以获取其哈希值；
                                                                                      
                                                                                      再处理其右子节点以获取其哈希值；
                                                                                      
                                                                                      最后将左右子节点的哈希值汇总生成该节点的哈希值；
  ----------------------------------------------------------------------------------------------------------------------------------------------------

考虑到该部分难度较大，这里选取了一个实例进行演示运算过程。该过程一步一步的演示了从空白的哈希树重建出部分哈希树，最终证明该哈希存在于该哈希树。

  ------------------------------------------------------------------------------------------------------------------------------------------
  图例
  
  ![图片包含 物体 已生成高可信度的说明](media/image62.png){width="0.296580271216098in" height="0.2076388888888889in"}等待子节点的计算
  
  ![图片包含 物体 已生成高可信度的说明](media/image62.png){width="0.3019805336832896in" height="0.19930555555555557in"}已计算出哈希值
  
  ![图片包含 物体 已生成高可信度的说明](media/image62.png){width="0.2965277777777778in" height="0.1980194663167104in"}从列表中选取了哈希值
  
  ![图片包含 物体 已生成高可信度的说明](media/image62.png){width="0.2965277777777778in" height="0.21388888888888888in"}目标的交易
  ------------------------------------------------------------------------------------------------------------------------------------------

  ---------------------------------------------------------------------------------------------------------------------------------------------
  哈希树                                                                               参数                    步骤详情
  ------------------------------------------------------------------------------------ ----------------------- --------------------------------
  ![](media/image63.png){width="1.8712871828521436in" height="1.1017705599300087in"}   哈希列表：H1 H2 H3 H4   根据交易数量初始化树形结构
                                                                                                               
                                                                                       标志位：1 0 1 1 1 0 0   

  ![](media/image64.png){width="1.8700787401574803in" height="1.101058617672791in"}    哈希列表：H1 H2 H3 H4   从根节点开始
                                                                                                               
                                                                                       标志位：1 0 1 1 1 0 0   执行**非交易节点-1**
                                                                                                               
                                                                                                               先处理左子节点

  ![](media/image65.png){width="1.8700787401574803in" height="1.101058617672791in"}    哈希列表：H1 H2 H3 H4   执行**非交易节点-0**
                                                                                                               
                                                                                       标志位：0 1 1 1 0 0     提取哈希值

  ![](media/image66.png){width="1.8700787401574803in" height="1.101058617672791in"}    哈希列表：H2 H3 H4      回到根节点
                                                                                                               
                                                                                       标志位： 1 1 0 0        继续处理右子节点
                                                                                                               
                                                                                                               执行**非交易节点-1**
                                                                                                               
                                                                                                               先处理左子节点

  ![](media/image67.png){width="1.8700787401574803in" height="1.101058617672791in"}    哈希列表：H2 H3 H4      执行**非交易节点-1**
                                                                                                               
                                                                                       标志位： 1 0 0          先处理左子节点

  ![](media/image68.png){width="1.8700787401574803in" height="1.101058617672791in"}    哈希列表：H2 H3 H4      执行**交易节点-1**
                                                                                                               
                                                                                       标志位： 0 0            提取哈希值
                                                                                                               
                                                                                                               标记为请求的交易

  ![](media/image69.png){width="1.8700787401574803in" height="1.101058617672791in"}    哈希列表：H3 H4         执行**交易节点-0**
                                                                                                               
                                                                                       标志位：0 0             提取哈希值

  ![](media/image70.png){width="1.8700787401574803in" height="1.101058617672791in"}    哈希列表：H4            根据左右子节点计算该节点哈希值
                                                                                                               
                                                                                       标志位：                

  ![](media/image71.png){width="1.8700787401574803in" height="1.101058617672791in"}    哈希列表：H4            执行**非交易节点-0**
                                                                                                               
                                                                                       标志位：                提取哈希值

  ![](media/image72.png){width="1.8700787401574803in" height="1.101058617672791in"}    哈希列表：H4            根据左右子节点计算该节点哈希值
                                                                                                               
                                                                                       标志位：                

  ![](media/image73.png){width="1.8700787401574803in" height="1.101058617672791in"}    哈希列表：H4            根据左右子节点计算该节点哈希值
                                                                                                               
                                                                                       标志位：                
  ---------------------------------------------------------------------------------------------------------------------------------------------

为了支持重建部分哈希树，在哈希树类中添加以下方法。

  --------------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** MerkleTree  
  
  2.  {  
  
  3.      **public** **static** UInt256 GetPartialTreeRootHash(**int** txNumber, UInt256\[\] hashes, BitArray flags)  
  
  4.      **private** **static** MerkleTreeNode BuildPartialTree(Queue&lt;UInt256&gt; hashes, **int** height, Queue&lt;**bool**&gt; flags)  
  
  5.  }  
  
  --------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTree.cs

其中，

-   第3行，获取该部分哈希树的根节点哈希值，通常可将该值与存于区块头中的默克尔树根值进行对比以确认信息未被更改，传入参数即为交易数量、哈希列表和标志位；

-   第4行，私有方法，被前项方法调用，用于实际构建部分哈希树，传入树高度（由交易的数量决定）、哈希列表和标志位，获得创建成功的部分哈希树树根节点的引用；

  ----------------------------------------------------------------------------------------------------------------------------------------
  1.  **private** **static** MerkleTreeNode BuildPartialTree(Queue&lt;UInt256&gt; hashes, **int** height, Queue&lt;**bool**&gt; flags)  
  
  2.  {  
  
  3.      **if** (height == 0) **return** **null**;  
  
  4.      var flag = flags.Dequeue();  
  
  5.      **if** (flag)  
  
  6.      {  
  
  7.          **if** (height == 1)  
  
  8.          {  
  
  9.              var leaf = **new** MerkleTreeNode(hashes.Dequeue()) { IsMarked = **true** };  
  
  10.             **return** leaf;  
  
  11.         }  
  
  12.         **else**  
  
  13.         {  
  
  14.             var left = BuildPartialTree(hashes, height - 1, flags);  
  
  15.             var right = BuildPartialTree(hashes, height - 1, flags);  
  
  16.             var parent = **new** MerkleTreeNode(left, right);  
  
  17.             **return** parent;  
  
  18.         }  
  
  19.     }  
  
  20.     **else**  
  
  21.     {  
  
  22.         **if** (height == 1)  
  
  23.         {  
  
  24.             var leaf = **new** MerkleTreeNode(hashes.Dequeue());  
  
  25.             **return** leaf;  
  
  26.         }  
  
  27.         **else**  
  
  28.         {  
  
  29.             var leaf = **new** MerkleTreeNode(hashes.Dequeue());  
  
  30.             **return** leaf;  
  
  31.         }  
  
  32.     }  
  
  33. }  
  
  ----------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTree.cs

其中，

-   第3行，本方法属于递归方法，
    每一次递归分别处理其左右子树时，均会将高度降低1，当高度为0时，说明已经出了该哈希树的界限，故返回空，表示无子节点了；

-   第4行，从标志位中取出一个标志；

-   第7行，高度为1，即说明该节点为交易节点。

-   第9-10行，按照交易节点-1处理：使用哈希列表中下一个哈希值作为该节点的哈希值，并且该节点就是请求中交易，代码中将其标记出来；

-   第14-17行，按照非交易节点-1处理；

-   第14行，先处理其左子节点以获取其哈希值；

-   第15行，再处理其右子节点以获取其哈希值；

-   第16-17行，最后将左右子节点的哈希值汇总生成该节点的哈希值；

-   第24-25行，按照交易节点-0处理：使用哈希列表中下一个哈希值作为该节点的哈希值，该节点并非请求的交易；

-   第29-30行，按照非交易节点-0处理：使用哈希列表中下一个哈希值作为该节点的哈希值，不再处理子节点；

以下方法通过调用前一个方法，返回该部分哈希树的根节点哈希值。

  -----------------------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **static** UInt256 GetPartialTreeRootHash(**int** txNumber, UInt256\[\] hashes, BitArray flags)  
  
  2.  {  
  
  3.      var height = (**int**)Math.Ceiling(Math.Log(txNumber, 2)) + 1;  
  
  4.      var tree = BuildPartialTree(**new** Queue&lt;UInt256&gt;(hashes), height, **new** Queue&lt;**bool**&gt;(flags.OfType&lt;**bool**&gt;()));  
  
  5.      **return** tree.Hash;  
  
  6.  }  
  
  -----------------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTree.cs

其中，

-   第3行，通过公式$height = \left\lceil \ \operatorname{}\text{txNumber\ } \right\rceil + 1$计算出该哈希树的高度；

-   第4行，调用创建部分哈希树的递归方法进行创建，并获得树根节点的引用；

-   第5行，返回树根的哈希值，可将该值与存于区块头中的默克尔树根值进行对比以确认信息的正确性；

#### 抽取部分哈希树

因为和重建部分哈希树相比，抽取部分哈希树显得更加抽象，所以才特意安排为先让读者理解了重建的过程后，再来学习抽取的过程。

抽取部分哈希树的过程就是从一颗完整的哈希树，根据所请求的节点，将含有该节点的及其验证节点的子树按照哈希列表和标志位的存储形式抽取出来。

在抽取部分哈希树时，会根据匹配规则对输出的哈希列表和标志位进行增加，规则如下表所示：

  --------------------------------------------------------------
           交易节点                 非交易节点
  -------- ------------------------ ----------------------------
  无标记   向标志位添加0；          向标志位添加0；
                                    
           将本节点添至哈希列表；   将本节点添至哈希列表；
                                    
                                    不再处理子节点；

  有标记   向标志位添加1；          向标志位添加1；
                                    
           将本节点添至哈希列表；   分别处理左右节点；
                                    
                                    不要将本节点添至哈希列表；
  --------------------------------------------------------------

其中，在启动时的第一步会对哈希树进行标记，将目标节点及其祖先标记出来，也因此将哈希树中的节点分成了有标记和无标记两种。

以下同样选取了和前一节同样的实例进行演示运算过程。该过程一步一步的演示了从完整哈希树抽取出部分哈希树，并以哈希列表和标志位的方式存储。

  ----------------------------------------------------------------------------------------------------------------------------------------------
  图例
  
  ![图片包含 屏幕截图 已生成高可信度的说明](media/image74.tmp){width="0.3013888888888889in" height="0.2263888888888889in"}等待子节点的计算
  
  ![图片包含 屏幕截图 已生成高可信度的说明](media/image74.tmp){width="0.3309000437445319in" height="0.23840879265091863in"}不需要的节点
  
  ![图片包含 屏幕截图 已生成高可信度的说明](media/image74.tmp){width="0.31288385826771653in" height="0.22013888888888888in"}放入哈希列表的节点
  
  ![图片包含 屏幕截图 已生成高可信度的说明](media/image74.tmp){width="0.3225667104111986in" height="0.23252405949256344in"}标记的节点
  ----------------------------------------------------------------------------------------------------------------------------------------------

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------
  哈希树                                                                               参数                      步骤详情
  ------------------------------------------------------------------------------------ ------------------------- ----------------------------------------------------
  ![](media/image75.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：&lt;空&gt;      初始化完整哈希树
                                                                                                                 
                                                                                       标志位：&lt;空&gt;        

  ![](media/image76.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：&lt;空&gt;      在哈希树中标记目标节点及其祖先
                                                                                                                 
                                                                                       标志位：&lt;空&gt;        

  ![](media/image77.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：&lt;空&gt;      执行**非交易节点-有标记**：
                                                                                                                 
                                                                                       标志位：1                 向标志位添加1；
                                                                                                                 
                                                                                                                 分别处理左右节点；
                                                                                                                 
                                                                                                                 不要将本节点添至哈希列表；

  ![](media/image78.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：H12             执行**非交易节点-无标记**：
                                                                                                                 
                                                                                       标志位：1 0               向标志位添加0；
                                                                                                                 
                                                                                                                 将本节点添至哈希列表；

  ![](media/image79.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：H12             执行**非交易节点-有标记**：
                                                                                                                 
                                                                                       标志位：1 0 1             向标志位添加1；
                                                                                                                 
                                                                                                                 分别处理左右节点；
                                                                                                                 
                                                                                                                 不要将本节点添至哈希列表；

  ![](media/image80.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：H12             执行**非交易节点-有标记**：
                                                                                                                 
                                                                                       标志位：1 0 1 1           向标志位添加1；
                                                                                                                 
                                                                                                                 分别处理左右节点；
                                                                                                                 
                                                                                                                 不要将本节点添至哈希列表；

  ![](media/image81.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：H12 H5          执行**交易节点-有标记**：
                                                                                                                 
                                                                                       标志位：1 0 1 1 1         向标志位添加1；
                                                                                                                 
                                                                                                                 将本节点添至哈希列表；

  ![](media/image82.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：H12 H5 H6       执行**交易节点-无标记**：
                                                                                                                 
                                                                                       标志位：1 0 1 1 1 0       向标志位添加0；
                                                                                                                 
                                                                                                                 将本节点添至哈希列表；

  ![](media/image83.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：H12 H5 H6       处理完左右节点，回退，但并不将该节点添至哈希列表；
                                                                                                                 
                                                                                       标志位：1 0 1 1 1 0       

  ![](media/image84.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：H12 H5 H6 H11   执行**非交易节点-无标记**：
                                                                                                                 
                                                                                       标志位：1 0 1 1 1 0 0     向标志位添加0；
                                                                                                                 
                                                                                                                 将本节点添至哈希列表；

  ![](media/image85.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：H12 H5 H6 H11   处理完左右节点，回退，但并不将该节点添至哈希列表；
                                                                                                                 
                                                                                       标志位：1 0 1 1 1 0 0     

  ![](media/image86.png){width="1.8700787401574803in" height="1.1333541119860018in"}   哈希列表：H12 H5 H6 H11   处理完左右节点，回退，但并不将该节点添至哈希列表；
                                                                                                                 
                                                                                       标志位：1 0 1 1 1 0 0     
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --------------------------------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** MerkleTree  
  
  2.  {  
  
  3.      **public** (UInt256\[\] hashes, BitArray flags) Trim(Predicate&lt;UInt256&gt; filter)  
  
  4.      **private** **static** **void** Trim(MerkleTreeNode root, List&lt;UInt256&gt; hashes, List&lt;**bool**&gt; flags, Predicate&lt;UInt256&gt; filter)  
  
  5.      **private** **static** **void** MarkToTop(MerkleTreeNode leaf, **bool** value)  
  
  6.      **private** **static** **void** TrimCore(MerkleTreeNode node, List&lt;UInt256&gt; hashes, List&lt;**bool**&gt; flags)  
  
  7.  }  
  
  --------------------------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTree.cs

其中，

-   第3行，

  --------------------------------------------------------------------------------------
  1.  **private** **static** **void** MarkToTop(MerkleTreeNode leaf, **bool** value)  
  
  2.  {  
  
  3.      leaf.IsMarked = value;  
  
  4.      **foreach** (var ancestor **in** leaf.Ancestors())  
  
  5.      {  
  
  6.          ancestor.IsMarked = value;  
  
  7.      }  
  
  8.  }  
  
  --------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTree.cs

其中，

-   第3行，

  -----------------------------------------------------------------------------------------------------------------------------
  1.  **private** **static** **void** TrimCore(MerkleTreeNode node, List&lt;UInt256&gt; hashes, List&lt;**bool**&gt; flags)  
  
  2.  {  
  
  3.      **if** (node == **null**)  
  
  4.          **return**;  
  
  5.      flags.Add(node.IsMarked);  
  
  6.      **if** (node.IsLeaf || !node.IsMarked)  
  
  7.          hashes.Add(node.Hash);  
  
  8.    
  
  9.      **if** (node.IsMarked)  
  
  10.     {  
  
  11.         TrimCore(node.Left, hashes, flags);  
  
  12.         TrimCore(node.Right, hashes, flags);  
  
  13.     }  
  
  14. }  
  
  -----------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTree.cs

其中，

-   第3行，

  ----------------------------------------------------------------------------------------------------------------------------------------------------------
  1.  **private** **static** **void** Trim(MerkleTreeNode root, List&lt;UInt256&gt; hashes, List&lt;**bool**&gt; flags, Predicate&lt;UInt256&gt; filter)  
  
  2.  {  
  
  3.      **foreach** (var leaf **in** root.GetLeafs().Where(\_ =&gt; filter(\_.Hash)))  
  
  4.      {  
  
  5.          MarkToTop(leaf, **true**);  
  
  6.      }  
  
  7.    
  
  8.      TrimCore(root, hashes, flags);  
  
  9.  }  
  
  ----------------------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTree.cs

其中，

-   第3行，

  ---------------------------------------------------------------------------------------------
  1.  **public** (UInt256\[\] hashes, BitArray flags) Trim(Predicate&lt;UInt256&gt; filter)  
  
  2.  {  
  
  3.      var flags = **new** List&lt;**bool**&gt;();  
  
  4.      var hashes = **new** List&lt;UInt256&gt;();  
  
  5.      Trim(root, hashes, flags, filter);  
  
  6.    
  
  7.      **return** (hashes.ToArray(), **new** BitArray(flags.ToArray()));  
  
  8.  }  
  
  ---------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\MerkleTree.cs

其中，

-   第3行，

### 交易的签名

#### 区块结构

在上一章基本的区块链程序中，我们已经有过区块结构的定义，不过为了使得支持轻量客户端，我们需要修改区块结构，将其分割开来，其中仅包含部分重要信息的部分被称为区块头，区块头中的信息有限且长度固定，不管这个区块中包含了多少交易，每一个区块头的长度均为固定值，这使得轻量客户端始终可以存储下所有的区块头，而轻量客户端存储了所有的区块头信息，才使得轻量客户端可以轻量的正确执行简单交易验证，而不会受到恶意服务器节点的欺骗。

如下图所示，跟上一章相比，我们将Transactions字段单独存在于区块结构中，而剩余字段以及一个新的MerkleRoot字段一同放到区块头中。

因此变更后，区块头中包含以下字段：

  字段                描述               类型
  ------------------- ------------------ ----------
  Version             版本号             Byte
  PreviousBlockHash   前一区块的哈希值   UInt256
  Time                时间戳             DateTime
  MerkleRoot          默克尔树根         UInt256
  Nonce               随机数             UInt32
  Hash                本区块的哈希值     UInt256

参考代码：ClassicBlockChain\\Entity\\Block.cs

该表格中的除了本区块的哈希值以外的所有字段，均会被作为本区块的哈希值计算的基础数据，故这些字段的任意一点变化均会导致本区块的哈希值的不同，除了默克尔树根之外的字段已于上一章详细解释过，这里仅详细解释新增的默克尔树根字段：

**默克尔树根**。将本区块中的所有交易使用本章学习的哈希树结构进行构造，并最终记录其树根的哈希值，即为默克尔树根。鉴于哈希树可以通过构建部分哈希树来轻量级的验证一笔交易是否存在于该哈希树，所以对于轻量客户端，仅需通过存储于客户端中默克尔树根便可以验证一笔交易是否存在于该区块中，即恶意节点无法通过告知一个不存在的交易以欺骗客户端。但值得注意的，恶意节点有可能告知客户端一笔实际存在的交易不存在，客户端需要通过向多个全节点查询以确认没有被欺骗。

#### 交易的结构

与上一章的程序相比，为了支持交易的签名，交易的输入输出结构发生了较大的变化，不过交易本身仍旧是链式交易这件事情没有变化。

![](media/image87.png){width="2.2341983814523183in"
height="1.956081583552056in"}

如上图所示，我们有三个类，下面分别进行详述。

首先是存储交易的主类：

  字段       描述             类型
  ---------- ---------------- --------------
  Version    版本号           Byte
  InputTxs   输入交易列表     TxInput\[\]
  Outputs    输出交易列表     TxOutput\[\]
  Hash       本交易的哈希值   UInt256

参考代码：ClassicBlockChain\\Entity\\Transaction.cs

该表格中的除了本交易的哈希值以外的所有字段，均会被作为本交易的哈希值计算的基础数据，故这些字段的任意一点变化均会导致本交易的哈希值的不同，以下对每个字段进行详细解释：

**版本号**。与前一章的定义相同，不再赘述。

**输出交易列表**。作为本次交易的输出，每个输出交易列表项均包含接收者公钥和资金数量两个字段，这每个输出交易均为可使用的交易，由可以使用该公钥对应私钥进行签名的用户进行使用。任意一笔输出交易在整个区块链的生命周期内均只可使用一次，对于从未使用过的输出交易，我们也称其为未使用的交易输出（UTXO）。

  字段        描述         类型
  ----------- ------------ -----------
  PublicKey   接收者公钥   PublicKey
  Value       资金数量     int

参考代码：ClassicBlockChain\\Entity\\TxOutput.cs

**输入交易列表**。作为本次交易资金源头输入的未使用交易列表，每一个输出交易均为可被使用的交易，而指向这笔输出交易的交易哈希值及输出交易序号便唯一的标记了一个可以使用的交易，每个输入交易列表项便需要包含指向一笔未使用交易的交易哈希值及输出交易序号，除此之外，创建此笔交易的用户还需要提供签名以证明自己拥有对前项输出交易的所有权。

  字段          描述                   类型
  ------------- ---------------------- -----------
  PrevTxHash    未使用交易的哈希值     UInt256
  PrevTxIndex   未使用交易的输出索引   int
  Signature     签名                   Signature

参考代码：ClassicBlockChain\\Entity\\TxInput.cs

**本交易的哈希值**。将以上所有字段的数据作为哈希运算的基础数据，计算出本交易的哈希值，但值得特别强调的是，区块链中所有的交易的哈希值都是不一样的，不会有重复的，相同哈希值的交易会在验证步骤被当作重复交易去除掉。对于矿工的CoinBase交易，因无输入，故需要对每笔交易使用不同的公钥，以确保该交易的哈希值唯一，为批量获得公私钥对，本章后续章节会介绍一种实现方式——确定性钱包。

#### 验证签名

  ------------------------------------------------------------------------------------------------------------------------
  private bool ValidateTx(Transaction tx)
  
  {
  
  if (this.BlockChain.ContainTx(tx.Hash)) return false;
  
  if (this.BlockChain.ContainUsedTxs(tx.InputTxs)) return false;
  
  foreach (var intx in tx.InputTxs)
  
  {
  
  var output = this.BlockChain.GetTx(intx.PrevTxHash).Outputs\[intx.PrevTxIndex\];
  
  var verifyTx = new Transaction
  
  {
  
  Version = tx.Version,
  
  InputTxs = tx.InputTxs
  
  .Select(\_ =&gt; new TxInput { PrevTxHash = \_.PrevTxHash, PrevTxIndex = \_.PrevTxIndex })
  
  .ToArray(),
  
  Outputs = tx.Outputs.ToArray(),
  
  };
  
  if (!this.signAlgo.Verify(new\[\] { Encoding.UTF8.GetBytes(verifyTx.HashContent) }, output.PublicKey, intx.Signature))
  
  return false;
  
  }
  
  return true;
  
  }
  ------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\Engine.cs

  --
  --

参考代码：ClassicBlockChain\\Utility\\ECDsaSignAlgorithm.cs

其中，

第3行，

### 轻量客户端

在第一章已经学习过轻量客户端的概念，并知道了并非所有的节点都有能力储存完整的区块链，因此对于这些被设计成运行在空间和功率受限的设备的轻量客户端，通过简化的支付验证(SPV)的方式可以使它们在不必存储完整区块链的情况下进行工作。轻量客户端仅仅需要下载区块头信息，而不用下载包含在每个区块中的交易信息。由此产生的不含交易信息的区块链，大小会远远小于完整的区块链，这样便适合在受限环境上执行。鉴于轻量客户端并不知道网络上所有交易的完整信息，其验证交易时所使用的方法略有不同，这个方法需依赖对等的全节点“按需"提供区块链中相关部分的局部视图。

在本节中。。。。。。

#### 客户端基础

  ------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **interface** IWallet  
  
  2.  {  
  
  3.      **string** Name { **get**; }  
  
  4.      PrivateKey PrivateKey { **get**; }  
  
  5.      PublicKey PublicKey { **get**; }  
  
  6.    
  
  7.      Transaction SendMoney(Engine engine, Transaction utxo, **int** index, IWallet receiver, **int** value, **int** fee = 0);  
  
  8.      Transaction SendMoney(Engine engine, Utxo\[\] utxos, **params** TxOutput\[\] outputs);  
  
  9.      **void** GenerateKeyPair();  
  
  10.     Utxo\[\] GetUtxos(Engine engine);  
  
  11.     **void** SyncBlockHead(Engine engine);  
  
  12.     **bool** VerifyTx(Engine engine, Transaction tx);  
  
  13. }  
  
  ------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\IWallet.cs

其中，

第3行，

  --------------------------------------------------------------------------------------
  1.  **public** **abstract** **class** BaseWallet : IWallet  
  
  2.  {  
  
  3.      **protected** ISignAlgorithm signAlgo = **new** ECDsaSignAlgorithm();  
  
  4.      **protected** Dictionary&lt;UInt256, BlockHead&gt; blockHeads  
  
  5.    
  
  6.      **protected** BaseWallet(**string** name)  
  
  7.      {  
  
  8.          **this**.Name = name;  
  
  9.          **this**.GenerateKeyPair();  
  
  10.     }  
  
  11.   
  
  12.     ...  
  
  13.   
  
  14.     **protected** **virtual** **void** AfterKeyPairGenerated()  
  
  15.     **protected** **abstract** PrivateKey FindPrivateKey(PublicKey publicKey);  
  
  16.     **protected** **abstract** **bool** ContainPubKey(PublicKey publicKey);  
  
  17. }  
  
  --------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\BaseWallet.cs

其中，

第3行，

  --------------------------------------------------------------------------------------------------------
  1.  **public** Transaction SendMoney(Engine engine, Utxo\[\] utxos, **params** TxOutput\[\] outputs)  
  
  2.  {  
  
  3.      var inputTxs = utxos  
  
  4.          .Select(\_ =&gt; **new** TxInput { PrevTxHash = \_.Tx.Hash, PrevTxIndex = \_.Index })  
  
  5.          .ToArray();  
  
  6.      var tx = **new** Transaction  
  
  7.      {  
  
  8.          InputTxs = inputTxs,  
  
  9.          Outputs = outputs,  
  
  10.     };  
  
  11.     var sigList = **new** Signature\[tx.InputTxs.Length\];  
  
  12.     **for** (**int** i = 0; i &lt; tx.InputTxs.Length; i++)  
  
  13.     {  
  
  14.         var utxoEnt = utxos\[i\];  
  
  15.         sigList\[i\] = **this**.signAlgo.Sign(  
  
  16.             **new**\[\] { Encoding.UTF8.GetBytes(tx.HashContent) },  
  
  17.             **this**.FindPrivateKey(utxoEnt.Tx.Outputs\[utxoEnt.Index\].PublicKey));  
  
  18.     }  
  
  19.   
  
  20.     **for** (**int** i = 0; i &lt; tx.InputTxs.Length; i++)  
  
  21.     {  
  
  22.         tx.InputTxs\[i\].Signature = sigList\[i\];  
  
  23.     }  
  
  24.     engine.AttachTx(tx);  
  
  25.   
  
  26.     **return** tx;  
  
  27. }  
  
  28. 
  --------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\BaseWallet.cs

其中，

第3行，

  ------------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** Transaction SendMoney(Engine engine, Transaction utxo, **int** index, IWallet receiver, **int** value, **int** fee = 0)  
  
  2.  {  
  
  3.      var total = utxo.Outputs\[index\].Value;  
  
  4.      var change = total - value - fee;  
  
  5.      var mainOutput = **new** TxOutput { PublicKey = receiver.PublicKey, Value = value };  
  
  6.      var changeOutput = **new** TxOutput { PublicKey = **this**.PublicKey, Value = change };  
  
  7.      **return** **this**.SendMoney(engine, **new**\[\] { **new** Utxo(utxo, index) }, mainOutput, changeOutput);  
  
  8.  }  
  
  ------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\BaseWallet.cs

其中，

第3行，

  ----------------------------------------------------------------------------------------------------
  1.  **public** Utxo\[\] GetUtxos(Engine engine)  
  
  2.  {  
  
  3.      var txlist = engine.BlockChain.TxToBlockDictionary  
  
  4.          .Select(\_ =&gt; engine.BlockChain.GetTx(\_.Key))  
  
  5.          .SelectMany(\_ =&gt; \_.Outputs.Select((txo, i) =&gt; **new** { tx = \_, txo, i }))  
  
  6.          .Where(\_ =&gt; **this**.ContainPubKey(\_.txo.PublicKey))  
  
  7.          .Where(\_ =&gt; !engine.BlockChain.UsedTxDictionary.ContainsKey((\_.tx.Hash, \_.i)))  
  
  8.          .Select(\_ =&gt; **new** Utxo(\_.tx, \_.i))  
  
  9.          .ToArray();  
  
  10.     **return** txlist;  
  
  11. }  
  
  ----------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\BaseWallet.cs

其中，

第3行，

  ----------------------------------------------------------------------------------------------------------------
  1.  **public** **void** SyncBlockHead(Engine engine)  
  
  2.  {  
  
  3.      var blocks = engine.BlockChain.BlockHeadDictionary.ToDictionary(\_ =&gt; \_.Key, \_ =&gt; \_.Value);  
  
  4.      var newBlockHash = blocks.Select(\_ =&gt; \_.Key).ToArray();  
  
  5.      var oldBlockHash = **this**.blockHeads.Select(\_ =&gt; \_.Key).ToArray();  
  
  6.      var excepts = oldBlockHash.Except(newBlockHash).ToArray();  
  
  7.      **if** (excepts.Length &gt; 0)  
  
  8.      {  
  
  9.          Console.WriteLine(\$"found \[{excepts.Length}\] diffs in sync block");  
  
  10.         **return**;  
  
  11.     }  
  
  12.     **this**.blockHeads = blocks;  
  
  13. }  
  
  ----------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\BaseWallet.cs

其中，

第3行，

  ---------------------------------------------------------------------------------------
  1.  **public** **bool** VerifyTx(Engine engine, Transaction tx)  
  
  2.  {  
  
  3.      var (hs, flags, txnum, block) = engine.GetMerkleBlock(tx.Hash);  
  
  4.      var merkleRoot = MerkleTree.GetPartialTreeRootHash(txnum, hs, flags);  
  
  5.      **if** (!**this**.blockHeads.ContainsKey(block.Hash)) **return** **false**;  
  
  6.      var localBlock = **this**.blockHeads\[block.Hash\];  
  
  7.      **return** merkleRoot == localBlock.MerkleRoot;  
  
  8.  }  
  
  ---------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\BaseWallet.cs

其中，

第3行，

#### 确定性钱包

  -------------------------------------------------------------------------
  1.  **public** **class** SimpleWallet : BaseWallet  
  
  2.  {  
  
  3.      **public** SimpleWallet(**string** name) : **base**(name) { }  
  
  4.  }  
  
  -------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\SimpleWallet.cs

其中，

第3行，

  ----------------------------------------------------------------------------------------------------
  1.  **public** **class** DeterministicWallet : BaseWallet    
  
  2.  {    
  
  3.      **private** List&lt;PublicKey&gt; usedPublicKeys = **new** List&lt;PublicKey&gt;();    
  
  4.      **private** List&lt;PrivateKey&gt; usedPrivateKeys = **new** List&lt;PrivateKey&gt;();    
  
  5.      
  
  6.      **public** DeterministicWallet(**string** name) : **base**(name) { }    
  
  7.  }    
  
  ----------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\DeterministicWallet.cs

其中，

第3行，

  -------------------------------------------------------------------
  1.  **protected** **override** **void** AfterKeyPairGenerated()  
  
  2.  {  
  
  3.      **this**.usedPrivateKeys.Add(**this**.PrivateKey);  
  
  4.      **this**.usedPublicKeys.Add(**this**.PublicKey);  
  
  5.  }  
  
  -------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\DeterministicWallet.cs

其中，

第3行，

  -----------------------------------------------------------------------------------------------
  1.  **protected** **override** PrivateKey FindPrivateKey(PublicKey publicKey)  
  
  2.  {  
  
  3.      var idx = **this**.usedPublicKeys.FindIndex(\_ =&gt; \_ == publicKey);  
  
  4.      **if** (idx == -1)  
  
  5.          **throw** **new** KeyNotFoundException("cannot find corresponding public key");  
  
  6.      **return** **this**.usedPrivateKeys\[idx\];  
  
  7.  }  
  
  -----------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\DeterministicWallet.cs

其中，

第3行，

  ------------------------------------------------------------------------------
  1.  **protected** **override** **bool** ContainPubKey(PublicKey publicKey)  
  
  2.  {  
  
  3.      **return** **this**.usedPublicKeys.Contains(publicKey);  
  
  4.  }  
  
  ------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\DeterministicWallet.cs

其中，

第3行，

#### 对交易签名

  --
  --

参考代码：ClassicBlockChain\\Utility\\ECDsaSignAlgorithm.cs

其中，

第3行，

#### 存储的信息

#### 找零与交易费

### 本章练习

#### 基本练习一 运行程序

分布式网络
----------

### 对等通信网络

#### 结构设计

#### 接口定义

  ----------------------------------------------------------------
  1.  **public** **interface** IListener : IDisposable  
  
  2.  {  
  
  3.      **event** EventHandler&lt;IPeer&gt; OnPeerConnected;  
  
  4.      **void** Start();  
  
  5.      **string** Address { **get**; }  
  
  6.  }  
  
  ----------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\IListener.cs

其中，

第3行，

  -----------------------------------------------------------------
  1.  **public** **interface** IPeer : IDisposable  
  
  2.  {  
  
  3.      **bool** IsConnected { **get**; }  
  
  4.      **string** TargetAddress { **get**; }  
  
  5.      **string** BaseAddress { **get**; }  
  
  6.      **void** Send(CommandBase command);  
  
  7.      CommandBase Receive();  
  
  8.      **void** Connect(**string** connectionString);  
  
  9.      **void** Close(**object** closingMessage = **null**);  
  
  10. }  
  
  -----------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\IPeer.cs

其中，

第3行，

  -----------------------------------------------------------
  1.  **public** **interface** IPeerFactory : IDisposable  
  
  2.  {  
  
  3.      IPeer Produce();  
  
  4.  }  
  
  -----------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\IPeerFactory.cs

其中，

第3行，

#### 模拟通信实现

为了简化场景，避免涉及更为艰深的网络通信问题，在此以模拟的形式实现网络通信。

  -----------------------------------------------------------------------------------------------------
  1.  **public** **abstract** **class** InMemoryPeerBase : IPeer  
  
  2.  {  
  
  3.      **protected** **internal** InMemoryPeerBase opposite;  
  
  4.      **protected** **readonly** InMemoryConnectionCenter center;  
  
  5.      **protected** Queue&lt;CommandBase&gt; receivedData = **new** Queue&lt;CommandBase&gt;();  
  
  6.    
  
  7.      **protected** InMemoryPeerBase(InMemoryConnectionCenter center)  
  
  8.      {  
  
  9.          **this**.center = center;  
  
  10.     }  
  
  11.   
  
  12.     **public** **string** TargetAddress { **get**; **protected** **set**; }  
  
  13.     **public** **string** BaseAddress { **get**; **protected** **set**; }  
  
  14.     **public** **bool** IsConnected { **get**; **protected** **set**; }  
  
  15.   
  
  16.     **public** **abstract** **void** Connect(**string** connectionString);  
  
  17.     **public** **void** Close(**object** closingMessage = **null**)  
  
  18.     **public** **void** Send(CommandBase command)  
  
  19.     **public** CommandBase Receive()  
  
  20. }  
  
  -----------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\InMemory\\InMemoryPeerBase.cs

其中，

第3行，

  ----------------------------------------------------------------------
  1.  **public** **void** Send(CommandBase command)  
  
  2.  {  
  
  3.      **this**.opposite.receivedData.Enqueue(command);  
  
  4.  }  
  
  5.    
  
  6.  **public** CommandBase Receive()  
  
  7.  {  
  
  8.      **if** (**this**.receivedData.TryDequeue(**out** var ret))  
  
  9.      {  
  
  10.         **return** ret;  
  
  11.     }  
  
  12.     **return** **null**;  
  
  13. }  
  
  ----------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\InMemory\\InMemoryPeerBase.cs

其中，

第3行，

  -----------------------------------------------------------------------
  1.  **public** **void** Close(**object** closingMessage = **null**)  
  
  2.  {  
  
  3.      **this**.IsConnected = **false**;  
  
  4.      **this**.center.RemovePeer(**this**);  
  
  5.  }  
  
  -----------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\InMemory\\InMemoryPeerBase.cs

其中，

第3行，

  -----------------------------------------------------------------------------------------------------------------
  1.  **public** **class** ActiveInMemoryPeer : InMemoryPeerBase  
  
  2.  {  
  
  3.      **public** ActiveInMemoryPeer(InMemoryConnectionCenter center, **string** address) : **base**(center)  
  
  4.      {  
  
  5.          **this**.BaseAddress = address;  
  
  6.      }  
  
  7.    
  
  8.      **public** **override** **void** Connect(**string** connectionString)  
  
  9.      {  
  
  10.         **this**.TargetAddress = connectionString;  
  
  11.         **if** (**this**.center.Connect(connectionString, **this**))  
  
  12.         {  
  
  13.             **this**.IsConnected = **true**;  
  
  14.             **this**.center.AddPeer(**this**);  
  
  15.         }  
  
  16.         **else**  
  
  17.         {  
  
  18.             **this**.IsConnected = **false**;  
  
  19.         }  
  
  20.     }  
  
  21. }  
  
  -----------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\InMemory\\ActiveInMemoryPeer.cs

其中，

第3行，

  -----------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** PassiveInMemoryPeer : InMemoryPeerBase  
  
  2.  {  
  
  3.      **public** PassiveInMemoryPeer(InMemoryConnectionCenter center, ActiveInMemoryPeer peer) : **base**(center)  
  
  4.      {  
  
  5.          **this**.opposite = peer;  
  
  6.          **this**.opposite.opposite = **this**;  
  
  7.          **this**.BaseAddress = peer.TargetAddress;  
  
  8.          **this**.TargetAddress = peer.BaseAddress;  
  
  9.      }  
  
  10.   
  
  11.     **public** **override** **void** Connect(**string** connectionString)  
  
  12.     {  
  
  13.         **throw** **new** NotSupportedException();  
  
  14.     }  
  
  15. }  
  
  -----------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\InMemory\\PassiveInMemoryPeer.cs

其中，

第3行，

  ----------------------------------------------------------------------------------------------------
  1.  **public** **class** InMemoryPeerFactory : IPeerFactory  
  
  2.  {  
  
  3.      **private** **readonly** InMemoryConnectionCenter center;  
  
  4.      **private** **readonly** InMemoryListener server;  
  
  5.    
  
  6.      **public** InMemoryPeerFactory(InMemoryConnectionCenter center, InMemoryListener server)  
  
  7.      {  
  
  8.          **this**.center = center;  
  
  9.          **this**.server = server;  
  
  10.     }  
  
  11.   
  
  12.     **public** IPeer Produce()  
  
  13.     {  
  
  14.         **return** **new** ActiveInMemoryPeer(**this**.center, **this**.server.Address);  
  
  15.     }  
  
  16. }  
  
  ----------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\InMemory\\InMemoryPeerFactory.cs

其中，

第3行，

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** InMemoryConnectionCenter  
  
  2.  {  
  
  3.      **private** **int** number = 0;  
  
  4.    
  
  5.      **private** **readonly** ConcurrentDictionary&lt;**string**, InMemoryListener&gt; dicServers = **new** ConcurrentDictionary&lt;**string**, InMemoryListener&gt;();  
  
  6.      **private** **readonly** ConcurrentDictionary&lt;**string**, List&lt;InMemoryPeerBase&gt;&gt; dicPeers = **new** ConcurrentDictionary&lt;**string**, List&lt;InMemoryPeerBase&gt;&gt;();  
  
  7.    
  
  8.      **public** NodeOptions NodeOptions { **get** =&gt; **new** NodeOptions { WellKnownNodes = **this**.ProduceWellKnownNodes() }; }  
  
  9.      **public** **string**\[\] ProduceWellKnownNodes() =&gt; Enumerable.Range(0, **this**.number).Select(\_ =&gt; \_.ToString()).ToArray();  
  
  10.   
  
  11.     **public** (IListener listener, IPeerFactory peerFactory) Produce()  
  
  12.     **internal** **void** AddPeer(InMemoryPeerBase peer)  
  
  13.     **internal** **void** RemovePeer(InMemoryPeerBase peer)  
  
  14.     **internal** **bool** Connect(**string** baseAddress, ActiveInMemoryPeer peer)  
  
  15. }  
  
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\InMemory\\InMemoryConnectionCenter.cs

其中，

第3行，

  ----------------------------------------------------------------------------
  1.  **public** (IListener listener, IPeerFactory peerFactory) Produce()  
  
  2.  {  
  
  3.      var listener = **this**.ProduceListener();  
  
  4.      var peerFactory = **this**.ProducePeerFactory(listener);  
  
  5.      **return** (listener, peerFactory);  
  
  6.  }  
  
  7.    
  
  8.  **private** InMemoryListener ProduceListener()  
  
  9.  {  
  
  10.     var address = **this**.number.ToString();  
  
  11.     var server = **new** InMemoryListener(**this**, address);  
  
  12.     **this**.dicServers\[address\] = server;  
  
  13.     **this**.number++;  
  
  14.     **return** server;  
  
  15. }  
  
  16.   
  
  17. **private** IPeerFactory ProducePeerFactory(InMemoryListener server)  
  
  18. {  
  
  19.     **return** **new** InMemoryPeerFactory(**this**, server);  
  
  20. }  
  
  ----------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\InMemory\\InMemoryConnectionCenter.cs

其中，

第3行，

  ------------------------------------------------------------------------------------------------------
  1.  **internal** **void** AddPeer(InMemoryPeerBase peer)  
  
  2.  {  
  
  3.      var key = peer.TargetAddress;  
  
  4.      **if** (**this**.dicPeers.ContainsKey(key))  
  
  5.          **this**.dicPeers\[key\].Add(peer);  
  
  6.      **else**  
  
  7.          **this**.dicPeers\[key\] = **new** List&lt;InMemoryPeerBase&gt;(**new**\[\] { peer });  
  
  8.  }  
  
  9.    
  
  10. **internal** **void** RemovePeer(InMemoryPeerBase peer)  
  
  11. {  
  
  12.     var key = peer.TargetAddress;  
  
  13.     **if** (**this**.dicPeers.ContainsKey(key))  
  
  14.         **this**.dicPeers\[key\].Remove(peer);  
  
  15. }  
  
  ------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\InMemory\\InMemoryConnectionCenter.cs

其中，

第3行，

  --------------------------------------------------------------------------------------
  1.  **internal** **bool** Connect(**string** baseAddress, ActiveInMemoryPeer peer)  
  
  2.  {  
  
  3.      **return** **this**.dicServers\[baseAddress\].Connect(peer);  
  
  4.  }  
  
  --------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\InMemory\\InMemoryConnectionCenter.cs

其中，

第3行，

  --------------------------------------------------------------------------------------------
  1.  **public** **class** InMemoryListener : IListener  
  
  2.  {  
  
  3.      **private** **readonly** InMemoryConnectionCenter center;  
  
  4.    
  
  5.      **public** InMemoryListener(InMemoryConnectionCenter center, **string** address)  
  
  6.      {  
  
  7.          **this**.center = center;  
  
  8.          **this**.Address = address;  
  
  9.      }  
  
  10.   
  
  11.     **public** **event** EventHandler&lt;IPeer&gt; OnPeerConnected;  
  
  12.   
  
  13.     **public** **string** Address { **get**; }  
  
  14.   
  
  15.     **public** **void** Start() { }  
  
  16.   
  
  17.     **internal** **bool** Connect(ActiveInMemoryPeer peer)  
  
  18.     {  
  
  19.         var oppositePeer = **new** PassiveInMemoryPeer(**this**.center, peer);  
  
  20.         **this**.center.AddPeer(oppositePeer);  
  
  21.         **this**.OnPeerConnected?.Invoke(**this**, oppositePeer);  
  
  22.         **return** **true**;  
  
  23.     }  
  
  24. }  
  
  --------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\InMemory\\InMemoryListener.cs

其中，

第3行，

#### 通信协议

  --------------------------------------------------------------------------------------------------
  1.  **public** **abstract** **class** CommandBase  
  
  2.  {  
  
  3.      **public** **abstract** **string** CommandType { **get**; }  
  
  4.      **public** **abstract** **void** OnReceived(Node node, ConnectionNode connectionNode);  
  
  5.  }  
  
  --------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\CommandBase.cs

其中，

第3行，

  --------------------------------------------------------------------------------------------
  1.  **public** **static** **class** Commands  
  
  2.  {  
  
  3.      **public** **const** **string** Version = nameof(Version);  
  
  4.      **public** **const** **string** VersionAcknowledge = nameof(VersionAcknowledge);  
  
  5.      **public** **const** **string** GetBlocks = nameof(GetBlocks);  
  
  6.      **public** **const** **string** Inventory = nameof(Inventory);  
  
  7.      **public** **const** **string** GetData = nameof(GetData);  
  
  8.      **public** **const** **string** Block = nameof(Block);  
  
  9.      **public** **const** **string** Transaction = nameof(Transaction);  
  
  10. }  
  
  --------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\Commands.cs

其中，

第3行，

### 网络管理

#### 节点管理

  -----------------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** Node : IDisposable  
  
  2.  {  
  
  3.      **private** **readonly** IListener listener;  
  
  4.      **private** **readonly** NodeOptions options;  
  
  5.      **private** **readonly** IPeerFactory peerFactory;  
  
  6.    
  
  7.      **public** Node(IWallet miner, IListener listener, IPeerFactory peerFactory, NodeOptions options = **null**)  
  
  8.      {  
  
  9.          **this**.Engine = **new** Engine(miner);  
  
  10.         **this**.options = options ?? **new** NodeOptions();  
  
  11.   
  
  12.         **this**.listener = listener;  
  
  13.         **this**.listener.Start();  
  
  14.         **this**.peerFactory = peerFactory;  
  
  15.         **this**.ConnPool = **new** ConnectionPool(**this**, **this**.options.WellKnownNodes, **this**.peerFactory, **this**.listener);  
  
  16.         **this**.ConnPool.Start();  
  
  17.     }  
  
  18.   
  
  19.     **public** Engine Engine { **get**; }  
  
  20.     **public** ConnectionPool ConnPool { **get**; }  
  
  21.   
  
  22.     **public** **void** Dispose()  
  
  23.     {  
  
  24.         **this**.Engine?.Dispose();  
  
  25.         **this**.listener.Dispose();  
  
  26.         **this**.ConnPool.Dispose();  
  
  27.         **this**.peerFactory.Dispose();  
  
  28.     }  
  
  29. }  
  
  -----------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\Node.cs

其中，

第3行，

  --------------------------------------------------------------------------
  1.  **public** **class** NodeOptions  
  
  2.  {  
  
  3.      **public** **string**\[\] WellKnownNodes { **get**; **set**; }  
  
  4.  }  
  
  --------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\NodeOptions.cs

其中，

第3行，

#### 连接管理

  --------------------------------------------
  1.  **public** **enum** ConnectionStatus  
  
  2.  {  
  
  3.      Initial,  
  
  4.      Connected,  
  
  5.      Disconnected,  
  
  6.      Dead,  
  
  7.  }  
  
  --------------------------------------------

参考代码：ClassicBlockChain\\Network\\ConnectionNode.cs

其中，

第3行，

  --------------------------------------------------------------------
  1.  **public** **class** ConnectionNode  
  
  2.  {  
  
  3.      **public** **string** Address { **get**; **set**; }  
  
  4.      **public** ConnectionStatus Status { **get**; **set**; }  
  
  5.      **public** IPeer Peer { **get**; **set**; }  
  
  6.  }  
  
  --------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\ConnectionNode.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** ConnectionPool : IDisposable  
  
  2.  {  
  
  3.      **private** **readonly** List&lt;ConnectionNode&gt; nodes;  
  
  4.      **private** **readonly** Node selfNode;  
  
  5.      **private** **readonly** IPeerFactory peerFactory;  
  
  6.      **private** **readonly** IListener listener;  
  
  7.      **public** ConnectionPool(Node node, **string**\[\] wellKnowns, IPeerFactory peerFactory, IListener listener)  
  
  8.      {  
  
  9.          **this**.selfNode = node;  
  
  10.         **this**.nodes = wellKnowns  
  
  11.             .Where(\_ =&gt; \_ != listener.Address)  
  
  12.             .Select(\_ =&gt; **new** ConnectionNode(\_))  
  
  13.             .ToList();  
  
  14.         **this**.peerFactory = peerFactory;  
  
  15.         **this**.listener = listener;  
  
  16.     }  
  
  17.   
  
  18.     **public** **void** Start()  
  
  19.     **public** **void** Dispose()  
  
  20. }  
  
  -------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\ConnectionPool.cs

其中，

第3行，

  -----------------------------------------------------------------------------------
  1.  **public** **class** ConnectionPool : IDisposable  
  
  2.  {  
  
  3.      **private** **bool** isReceiving = **false**;  
  
  4.      **private** Thread thReceive;  
  
  5.      **public** **event** EventHandler&lt;CommandBase&gt; OnCommandReceived;  
  
  6.    
  
  7.      **public** **void** Start()  
  
  8.      {  
  
  9.          **this**.thReceive = **new** Thread(Receive);  
  
  10.         **this**.thReceive.Start();  
  
  11.         **this**.isReceiving = **true**;  
  
  12.     }  
  
  13.   
  
  14.     **private** **void** Receive()  
  
  15.     {  
  
  16.         **while** (**this**.isReceiving)  
  
  17.         {  
  
  18.             ConnectionNode\[\] internalnodes;  
  
  19.             **lock** (**this**.nodes)  
  
  20.             {  
  
  21.                 internalnodes = **this**.nodes.ToArray();  
  
  22.             }  
  
  23.             **foreach** (var node **in** internalnodes)  
  
  24.             {  
  
  25.                 **if** (node.Peer == **null**) **continue**;  
  
  26.                 var command = node.Peer.Receive();  
  
  27.                 **if** (command == **null**) **continue**;  
  
  28.                 OnCommandReceived?.Invoke(**this**, command);  
  
  29.                 command.OnReceived(**this**.selfNode, node);  
  
  30.                 **if** (!**this**.isReceiving) **break**;  
  
  31.             }  
  
  32.   
  
  33.             Thread.Sleep(500);  
  
  34.         }  
  
  35.     }  
  
  36. }  
  
  -----------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\ConnectionPool.cs

其中，

第3行，

#### 节点连接

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** ConnectionPool : IDisposable  
  
  2.  {  
  
  3.      **private** Timer reconnectTimer;  
  
  4.    
  
  5.      **public** **void** Start()  
  
  6.      {  
  
  7.          ...  
  
  8.          **this**.reconnectTimer = **new** Timer((\_) =&gt; **this**.ConnectAll(), **null**, **new** TimeSpan(0, 0, 0, 0, 100), **new** TimeSpan(0, 0, 20));  
  
  9.      }  
  
  10.   
  
  11.     **private** **void** ConnectAll()  
  
  12.     {  
  
  13.         ConnectionNode\[\] internalnodes;  
  
  14.         **lock** (**this**.nodes)  
  
  15.         {  
  
  16.             internalnodes = **this**.nodes  
  
  17.                 .Where(\_ =&gt; \_.Status == ConnectionStatus.Initial || \_.Status == ConnectionStatus.Dead)  
  
  18.                 .Where(\_ =&gt; \_.Address != **null**)  
  
  19.                 .ToArray();  
  
  20.         }  
  
  21.         **foreach** (var node **in** internalnodes)  
  
  22.         {  
  
  23.             **this**.TryConnect(node);  
  
  24.         }  
  
  25.     }  
  
  26. }  
  
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\ConnectionPool.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** ConnectionPool : IDisposable  
  
  2.  {  
  
  3.      **private** Timer reconnectTimer;  
  
  4.    
  
  5.      **public** **void** Start()  
  
  6.      {  
  
  7.          ...  
  
  8.          **this**.reconnectTimer = **new** Timer((\_) =&gt; **this**.ConnectAll(), **null**, **new** TimeSpan(0, 0, 0, 0, 100), **new** TimeSpan(0, 0, 20));  
  
  9.      }  
  
  10.   
  
  11.     **private** **void** ConnectAll()  
  
  12.     {  
  
  13.         ConnectionNode\[\] internalnodes;  
  
  14.         **lock** (**this**.nodes)  
  
  15.         {  
  
  16.             internalnodes = **this**.nodes  
  
  17.                 .Where(\_ =&gt; \_.Status == ConnectionStatus.Initial || \_.Status == ConnectionStatus.Dead)  
  
  18.                 .Where(\_ =&gt; \_.Address != **null**)  
  
  19.                 .ToArray();  
  
  20.         }  
  
  21.         **foreach** (var node **in** internalnodes)  
  
  22.         {  
  
  23.             **this**.TryConnect(node);  
  
  24.         }  
  
  25.     }  
  
  26. }  
  
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\ConnectionPool.cs

其中，

第3行，

  ------------------------------------------------------------------
  1.  **private** **void** TryConnect(ConnectionNode node)  
  
  2.  {  
  
  3.      **if** (node.Peer != **null**)  
  
  4.      {  
  
  5.          node.Peer.Dispose();  
  
  6.          node.Peer = **null**;  
  
  7.      }  
  
  8.    
  
  9.      var peer = **this**.peerFactory.Produce();  
  
  10.     **try**  
  
  11.     {  
  
  12.         peer.Connect(node.Address);  
  
  13.         node.Peer = peer;  
  
  14.     }  
  
  15.     **catch** (Exception)  
  
  16.     {  
  
  17.         node.Status = ConnectionStatus.Dead;  
  
  18.     }  
  
  19.   
  
  20.     **if** (!peer.IsConnected)  
  
  21.     {  
  
  22.         Debug.WriteLine("open peer channel failed");  
  
  23.         node.Status = ConnectionStatus.Dead;  
  
  24.         **return**;  
  
  25.     }  
  
  26.   
  
  27.     **try**  
  
  28.     {  
  
  29.         peer.Send(**new** VersionCommand());  
  
  30.     }  
  
  31.     **catch** (Exception)  
  
  32.     {  
  
  33.         node.Status = ConnectionStatus.Dead;  
  
  34.     }  
  
  35.     **finally**  
  
  36.     {  
  
  37.         **if** (node.Status != ConnectionStatus.Connected)  
  
  38.         {  
  
  39.             peer.Close();  
  
  40.             peer.Dispose();  
  
  41.         }  
  
  42.     }  
  
  43. }  
  
  ------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\ConnectionPool.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------------
  1.  **public** **class** VersionCommand : CommandBase  
  
  2.  {  
  
  3.      **public** **override** **void** OnReceived(Node node, ConnectionNode connectionNode)  
  
  4.      {  
  
  5.          connectionNode.Status = ConnectionStatus.Connected;  
  
  6.          connectionNode.Peer.Send(**new** VersionAcknowledgeCommand());  
  
  7.      }  
  
  8.  }  
  
  -------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\VersionCommand.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------------
  1.  **public** **class** VersionAcknowledgeCommand : CommandBase  
  
  2.  {  
  
  3.      **public** **override** **void** OnReceived(Node node, ConnectionNode connectionNode)  
  
  4.      {  
  
  5.          connectionNode.Status = ConnectionStatus.Connected;  
  
  6.      }  
  
  7.  }  
  
  -------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\VersionAcknowledgeCommand.cs

其中，

第3行，

### 广播信息

#### 主动广播信息

  ----------------------------------------------------------------------------
  1.  **private** **void** Broadcast(CommandBase command)  
  
  2.  {  
  
  3.      ConnectionNode\[\] internalnodes;  
  
  4.      **lock** (**this**.nodes)  
  
  5.      {  
  
  6.          internalnodes = **this**.nodes  
  
  7.              .Where(\_ =&gt; \_.Status == ConnectionStatus.Connected)  
  
  8.              .ToArray();  
  
  9.      }  
  
  10.     **foreach** (var node **in** internalnodes)  
  
  11.     {  
  
  12.         node.Peer.Send(command);  
  
  13.     }  
  
  14. }  
  
  ----------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\ConnectionPool.cs

其中，

第3行，

#### 广播区块

  ------------------------------------------------------------------------------------------
  1.  **public** **class** ConnectionPool : IDisposable  
  
  2.  {  
  
  3.      **public** ConnectionPool(...)  
  
  4.      {  
  
  5.          ...  
  
  6.          **this**.selfNode.Engine.OnNewBlockCreated += Engine\_OnNewBlockCreated;  
  
  7.      }  
  
  8.    
  
  9.      **private** **void** Engine\_OnNewBlockCreated(**object** sender, BlockHead e)  
  
  10.     {  
  
  11.         var blk = **this**.selfNode.Engine.BlockChain.GetBlock(e.Hash);  
  
  12.         **this**.Broadcast(**new** BlockCommand { Block = blk });  
  
  13.     }  
  
  14. }  
  
  ------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\ConnectionPool.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------------
  1.  **public** **class** BlockCommand : CommandBase  
  
  2.  {  
  
  3.      **public** Block Block { **get**; **set**; }  
  
  4.    
  
  5.      **public** **override** **void** OnReceived(Node node, ConnectionNode connectionNode)  
  
  6.      {  
  
  7.          var engine = node.Engine;  
  
  8.          var bc = engine.BlockChain;  
  
  9.          **if** (bc.BlockHeadDictionary.ContainsKey(**this**.Block.Hash)) **return**;  
  
  10.         bc.AddSyncBlock(**this**.Block);  
  
  11.     }  
  
  12. }  
  
  -------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\BlockCommand.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------------------------------
  1.  **internal** **void** AddSyncBlock(Block block)  
  
  2.  {  
  
  3.      CacheBlock(block);  
  
  4.      // just cache block if prevous block not exist  
  
  5.      **if** (!**this**.BlockHeadDictionary.ContainsKey(block.Head.PreviousBlockHash)) **return**;  
  
  6.      **if** (**this**.TryMoveSyncTail(block.Head))  
  
  7.      {  
  
  8.          **this**.cancelSearchNonce = **true**;  
  
  9.      }  
  
  10. }  
  
  11.   
  
  12. **private** **void** CacheBlock(Block block)  
  
  13. {  
  
  14.     **this**.BlockDictionary\[block.Hash\] = block;  
  
  15.     **this**.InitBlocks(block.Head);  
  
  16. }  
  
  17.   
  
  18. **private** **bool** TryMoveSyncTail(BlockHead newTail)  
  
  19. {  
  
  20.     var listnow = **this**.ReverseIterateBlockHeaders(GenesisBlockHead.Hash, **this**.Tail.Hash).ToArray();  
  
  21.     var listnew = **this**.ReverseIterateBlockHeaders(GenesisBlockHead.Hash, newTail.Hash).ToArray();  
  
  22.     // broken chain should not count  
  
  23.     **if** (listnew.LastOrDefault()?.Hash != GenesisBlockHead.Hash) **return** **false**;  
  
  24.     var cnow = listnow.Length;  
  
  25.     var cnew = listnew.Length;  
  
  26.     **if** (cnew &gt; cnow)  
  
  27.     {  
  
  28.         MaintainBlockChain(newTail);  
  
  29.         **return** **true**;  
  
  30.     }  
  
  31.   
  
  32.     **return** **false**;  
  
  33. }  
  
  -------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

第3行，

#### 广播交易

  -----------------------------------------------------------------------------------------
  1.  **public** **class** ConnectionPool : IDisposable  
  
  2.  {  
  
  3.      **public** ConnectionPool(...)  
  
  4.      {  
  
  5.          ...  
  
  6.          **this**.selfNode.Engine.OnNewTxCreated += Engine\_OnNewTxCreated;  
  
  7.      }  
  
  8.    
  
  9.      **private** **void** Engine\_OnNewTxCreated(**object** sender, Transaction e)  
  
  10.     {  
  
  11.         **this**.Broadcast(**new** TransactionCommand { Transaction = e });  
  
  12.     }  
  
  13. }  
  
  -----------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\ConnectionPool.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------------
  1.  **public** **class** TransactionCommand : CommandBase  
  
  2.  {  
  
  3.      **public** Transaction Transaction { **get**; **set**; }  
  
  4.      **public** **override** **void** OnReceived(Node node, ConnectionNode connectionNode)  
  
  5.      {  
  
  6.          var bc = node.Engine.BlockChain;  
  
  7.          bc.SyncTx(**this**.Transaction);  
  
  8.      }  
  
  9.  }  
  
  -------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\TransactionCommand.cs

其中，

第3行，

  ----------------------------------------------------
  1.  **internal** **void** SyncTx(Transaction tx)  
  
  2.  {  
  
  3.      **this**.TxQueue.Enqueue(tx);  
  
  4.  }  
  
  ----------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

第3行，

#### 广播清单

  -----------------------------------------
  1.  **public** **enum** InventoryType  
  
  2.  {  
  
  3.      Transaction,  
  
  4.      Block,  
  
  5.  }  
  
  -----------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\InventoryEntity.cs

其中，

第3行，

  ---------------------------------------------------------------
  1.  **public** **class** InventoryEntity  
  
  2.  {  
  
  3.      **public** InventoryType Type { **get**; **set**; }  
  
  4.      **public** UInt256 Hash { **get**; **set**; }  
  
  5.  }  
  
  ---------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\InventoryEntity.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------------
  1.  **public** **class** InventoryCommand : CommandBase  
  
  2.  {  
  
  3.      **public** InventoryEntity\[\] Items { **get**; **set**; }  
  
  4.      **public** **override** **void** OnReceived(Node node, ConnectionNode connectionNode)  
  
  5.      {  
  
  6.          var responseCmd = **new** GetDataCommand { Items = **this**.Items };  
  
  7.          connectionNode.Peer.Send(responseCmd);  
  
  8.      }  
  
  9.  }  
  
  -------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\InventoryCommand.cs

其中，

第3行，

### 达成共识

#### 快速区块补足定位算法

  -----------------------------------------------------------------------------------
  1.  **private** **static** **long**\[\] GetBlockLocatorIndexes(**long** height)  
  
  2.  {  
  
  3.      var indexes = **new** List&lt;**long**&gt;();  
  
  4.      var step = 1;  
  
  5.      var i = height;  
  
  6.      **do**  
  
  7.      {  
  
  8.          **if** (indexes.Count &gt;= 10) step \*= 2;  
  
  9.          indexes.Add(i);  
  
  10.         i -= step;  
  
  11.     } **while** (i &gt; 0);  
  
  12.   
  
  13.     indexes.Add(0);  
  
  14.     **return** indexes.ToArray();  
  
  15. }  
  
  -----------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

第3行，

  -------------------------------------------------------------------
  1.  **public** UInt256\[\] GetBlockLocatorHashes()  
  
  2.  {  
  
  3.      var indexes = GetBlockLocatorIndexes(**this**.Height);  
  
  4.      **return** **this**.GetBlockHeaders(**this**.Tail.Hash)  
  
  5.          .Where((hd, i) =&gt; indexes.Contains(i))  
  
  6.          .Select(\_ =&gt; \_.Hash)  
  
  7.          .ToArray();  
  
  8.  }  
  
  -------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

第3行，

#### 区块补足机制

#### 旧节点数据提供

  ------------------------------------------------------------------------------------------------------------
  1.  **public** IEnumerable&lt;Block&gt; GetBlocks(UInt256 startingHash)  
  
  2.  {  
  
  3.      **return** **this**.GetBlockHeaders(startingHash)  
  
  4.          .Select(\_ =&gt; **this**.GetBlock(\_.Hash));  
  
  5.  }  
  
  6.    
  
  7.  **public** IEnumerable&lt;BlockHead&gt; GetBlockHeaders(UInt256 startingHash)  
  
  8.  {  
  
  9.      **return** **this**.ReverseIterateBlockHeaders(startingHash, **this**.Tail.Hash)  
  
  10.         .Reverse();  
  
  11. }  
  
  12.   
  
  13. **internal** IEnumerable&lt;BlockHead&gt; ReverseIterateBlockHeaders(UInt256 from, UInt256 to)  
  
  14. {  
  
  15.     var cursor = **this**.BlockHeadDictionary\[to\];  
  
  16.     **while** (cursor.Hash != from)  
  
  17.     {  
  
  18.         **if** (cursor.PreviousBlockHash == **null**) yield **break**;  
  
  19.         yield **return** cursor;  
  
  20.         **if** (!**this**.BlockHeadDictionary.TryGetValue(cursor.PreviousBlockHash, **out** cursor))  
  
  21.             yield **break**;  
  
  22.     }  
  
  23.   
  
  24.     yield **return** cursor;  
  
  25. }  
  
  ------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\BlockChain.cs

其中，

第3行，

  --------------------------------------------------------------------------------------------------
  1.  **public** **class** GetDataCommand : CommandBase  
  
  2.  {  
  
  3.      **public** InventoryEntity\[\] Items { **get**; **set**; }  
  
  4.      **public** **override** **void** OnReceived(Node node, ConnectionNode connectionNode)  
  
  5.      {  
  
  6.          var bc = node.Engine.BlockChain;  
  
  7.          **foreach** (var item **in** **this**.Items)  
  
  8.          {  
  
  9.              **switch** (item.Type)  
  
  10.             {  
  
  11.                 **case** InventoryType.Transaction:  
  
  12.                     var tx = bc.GetTx(item.Hash);  
  
  13.                     **if** (tx != **null**)  
  
  14.                     {  
  
  15.                         var responseCmd = **new** TransactionCommand { Transaction = tx };  
  
  16.                         connectionNode.Peer.Send(responseCmd);  
  
  17.                     }  
  
  18.                     **break**;  
  
  19.                 **case** InventoryType.Block:  
  
  20.                     var blk = bc.GetBlock(item.Hash);  
  
  21.                     **if** (blk != **null**)  
  
  22.                     {  
  
  23.                         var responseCmd = **new** BlockCommand { Block = blk };  
  
  24.                         connectionNode.Peer.Send(responseCmd);  
  
  25.                     }  
  
  26.                     **break**;  
  
  27.                 **default**:  
  
  28.                     **break**;  
  
  29.             }  
  
  30.         }  
  
  31.     }  
  
  32. }  
  
  --------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\GetDataCommand.cs

其中，

第3行，

#### 新节点数据获取

  --------------------------------------------------------------------------------------------------
  1.  **public** **class** BlockCommand : CommandBase  
  
  2.  {  
  
  3.      **public** **override** **void** OnReceived(Node node, ConnectionNode connectionNode)  
  
  4.      {  
  
  5.          ...  
  
  6.          **if** (bc.BlockHeadDictionary.ContainsKey(**this**.Block.Head.PreviousBlockHash))  
  
  7.          {  
  
  8.              var getblkcmd = **new** GetBlocksCommand  
  
  9.              {  
  
  10.                 BlockLocators = engine.BlockChain.GetBlockLocatorHashes(),  
  
  11.                 LastBlockHash = bc.Tail.Hash,  
  
  12.             };  
  
  13.             connectionNode.Peer.Send(getblkcmd);  
  
  14.         }  
  
  15.     }  
  
  16. }  
  
  --------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\BlockCommand.cs

其中，

第3行，

  -------------------------------------------------------------------------------
  1.  **public** **abstract** **class** BlockLocatorCommandBase : CommandBase  
  
  2.  {  
  
  3.      **public** UInt256 LastBlockHash { **get**; **set**; }  
  
  4.      **public** UInt256\[\] BlockLocators { **get**; **set**; }  
  
  5.  }  
  
  -------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\BlockLocatorCommandBase.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------------------
  1.  **public** **class** GetBlocksCommand : BlockLocatorCommandBase  
  
  2.  {  
  
  3.      **private** **const** **int** MaxBlockRetrivalNumber = 100;  
  
  4.      **public** **override** **void** OnReceived(Node node, ConnectionNode connectionNode)  
  
  5.      {  
  
  6.          var engine = node.Engine;  
  
  7.          var recentValidHash = UInt256.Zero;  
  
  8.    
  
  9.          **for** (**int** i = 0; i &lt; **this**.BlockLocators.Length; i++)  
  
  10.         {  
  
  11.             var hash = **this**.BlockLocators\[i\];  
  
  12.   
  
  13.             **if** (engine.BlockChain.BlockHeadDictionary.TryGetValue(hash, **out** var block))  
  
  14.             {  
  
  15.                 recentValidHash = block.Hash;  
  
  16.                 **break**;  
  
  17.             }  
  
  18.         }  
  
  19.   
  
  20.         var items = engine.BlockChain.GetBlockHeaders(recentValidHash)  
  
  21.             .Take(MaxBlockRetrivalNumber)  
  
  22.             .Select(\_ =&gt; **new** InventoryEntity(InventoryType.Block, \_.Hash))  
  
  23.             .ToArray();  
  
  24.   
  
  25.         var responseCmd = **new** InventoryCommand { Items = items };  
  
  26.         connectionNode.Peer.Send(responseCmd);  
  
  27.     }  
  
  28. }  
  
  -------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Network\\RpcCommands\\GetBlocksCommand.cs

其中，

第3行，

#### 工作量证明（POW）

### 本章练习

#### 搭建练习环境

  -------------------------------------------------------------------------------
  1.  **public** **class** ControlService  
  
  2.  {  
  
  3.      **private** **readonly** IHubContext&lt;ControlHub&gt; hubcontext;  
  
  4.      **public** ControlService(IHubContext&lt;ControlHub&gt; hubcontext)  
  
  5.      {  
  
  6.          **this**.hubcontext = hubcontext;  
  
  7.      }  
  
  8.    
  
  9.      **public** Task Start()  
  
  10.     **public** Task Stop()  
  
  11.     **public** Task AddNode()  
  
  12. }  
  
  -------------------------------------------------------------------------------

参考代码：DebugConsole\\Services\\ControlService.cs

其中，

第3行，

  --
  --

参考代码：DebugConsole\\Services\\ControlService.cs

其中，

第3行，

  --
  --

参考代码：DebugConsole\\Services\\ControlService.cs

其中，

第3行，

  --
  --

参考代码：DebugConsole\\Services\\ControlService.cs

其中，

第3行，

  --
  --

参考代码：DebugConsole\\Services\\ControlService.cs

其中，

第3行，

  --
  --

参考代码：DebugConsole\\Services\\ControlService.cs

其中，

第3行，

#### 基本练习一 运行程序

#### 扩展练习一 同步时验证区块内容

智能合约
--------

### 最简合约：锁定时间

#### 交易结构

  ------------------------------------------------------
  public class Transaction : HashBase
  
  {
  
  private byte version;
  
  private TxInput\[\] inputTxs = new TxInput\[\] { };
  
  private TxOutput\[\] outputs = new TxOutput\[\] { };
  
  private uint lockTime;
  
  }
  ------------------------------------------------------

参考代码：ClassicBlockChain\\Entity\\Transaction.cs

其中，

第3行，

#### 验证交易

  ---------------------------------------------------------------------------------
  1.  **public** **class** Engine : IDisposable  
  
  2.  {  
  
  3.      **private** **const** **uint** LockTimeBreakPoint = 1\_500\_000\_000;  
  
  4.      **private** BlockHead GenerateBlock()  
  
  5.      {  
  
  6.          var finalTxs = **this**.BlockChain.DequeueTxs()  
  
  7.              .Where(**this**.ValidateTx)  
  
  8.              .Where(**this**.ValidateLockTime)  
  
  9.              .ToList();  
  
  10.         ...  
  
  11.     }  
  
  12.   
  
  13.     **private** **bool** ValidateLockTime(Transaction tx)  
  
  14. }  
  
  ---------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\Engine.cs

其中，

第3行，

  ------------------------------------------------------------------------------------
  1.  **private** **bool** ValidateLockTime(Transaction tx)  
  
  2.  {  
  
  3.      **return** tx.InputTxs  
  
  4.          .Select(\_ =&gt; **this**.BlockChain.GetTx(\_.PrevTxHash))  
  
  5.          .All(\_ =&gt; **this**.ValidateLockTime(\_.LockTime, DateTime.Now));  
  
  6.  }  
  
  7.    
  
  8.  **private** **bool** ValidateLockTime(**uint** lockTime, DateTime time)  
  
  9.  {  
  
  10.     **if** (lockTime == 0) **return** **true**;  
  
  11.     **if** (lockTime &gt; LockTimeBreakPoint)  
  
  12.     {  
  
  13.         var lockdt = DateTimeOffset.FromUnixTimeSeconds(lockTime);  
  
  14.         **return** lockdt &gt; time;  
  
  15.     }  
  
  16.     **else**  
  
  17.     {  
  
  18.         **return** **this**.BlockChain.Height &gt; lockTime;  
  
  19.     }  
  
  20. }  
  
  ------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\Engine.cs

其中，

第3行，

### 执行环境

#### 虚拟机基础

#### 操作指令

  ---------------------------------------------
  1.  **public** **enum** OpCode : **byte**  
  
  2.  {  
  
  3.      Object,  
  
  4.      CheckSignature,  
  
  5.  }  
  
  ---------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\OpCode.cs

其中，

第3行，

#### 栈指令类

  ----------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** ScriptToken   
  
  2.  {  
  
  3.      **public** **const** **string** TOKEN\_PREFIX = "OC\_";  
  
  4.      **public** **bool** IsOpCode { **get** =&gt; **this**.OpCode != OpCode.Object; }  
  
  5.      **public** OpCode OpCode { **get**; **set**; } = OpCode.Object;  
  
  6.      **public** **string** Object { **get**; **set**; }  
  
  7.    
  
  8.      **public** ScriptToken(**object** obj)  
  
  9.      {  
  
  10.         **if** (obj **is** OpCode opcode)  
  
  11.         {  
  
  12.             **this**.OpCode = opcode;  
  
  13.         }  
  
  14.         **else** **if** (obj **is** **string** str)  
  
  15.         {  
  
  16.             **if** (str.StartsWith(TOKEN\_PREFIX))  
  
  17.             {  
  
  18.                 **this**.OpCode = (OpCode)Enum.Parse(**typeof**(OpCode), str.Remove(0, TOKEN\_PREFIX.Length));  
  
  19.             }  
  
  20.             **else**  
  
  21.             {  
  
  22.                 **this**.Object = str;  
  
  23.             }  
  
  24.         }  
  
  25.         **else**  
  
  26.         {  
  
  27.             **this**.Object = obj.ToString();  
  
  28.         }  
  
  29.     }  
  
  30.   
  
  31.     **public** **string** GetValue()  
  
  32.     **public** **static** ScriptToken CreateToken(**object** obj)  
  
  33.     **public** **override** **bool** Equals(**object** obj)  
  
  34.     **public** **override** **int** GetHashCode()  
  
  35. }  
  
  ----------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\ScriptToken.cs

其中，

第3行，

#### 指令辅助类

  ----------------------------------------------------------------------------------
  1.  **public** **class** UnlockScripts : ReadOnlyCollection&lt;ScriptToken&gt;  
  
  2.  {  
  
  3.      **public** UnlockScripts(IList&lt;ScriptToken&gt; list)  
  
  4.          : **base**(list)  
  
  5.      {  
  
  6.      }  
  
  7.  }  
  
  ----------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\UnlockScripts.cs

其中，

第3行，

  --------------------------------------------------------------------------------
  1.  **public** **class** LockScripts : ReadOnlyCollection&lt;ScriptToken&gt;  
  
  2.  {  
  
  3.      **public** LockScripts(IList&lt;ScriptToken&gt; list)  
  
  4.          : **base**(list)  
  
  5.      {  
  
  6.      }  
  
  7.  }  
  
  --------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\LockScripts.cs

其中，

第3行，

  ---------------------------------------------------------------------------------
  1.  **public** **class** WholeScripts : ReadOnlyCollection&lt;ScriptToken&gt;  
  
  2.  {  
  
  3.      **public** WholeScripts(IList&lt;ScriptToken&gt; list)  
  
  4.          : **base**(list)  
  
  5.      {  
  
  6.      }  
  
  7.  }  
  
  ---------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\WholeScripts.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------
  1.  **public** **static** WholeScripts **operator** +(UnlockScripts us, LockScripts ls)  
  
  2.      =&gt; **new** WholeScripts(us.Concat(ls).ToList());  
  
  -------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\UnlockScripts.cs

其中，

第3行，

#### 执行

  ----------------------------------------------------------------------------------------------------------------------------
  1.  **public** **static** T Evaluate&lt;T&gt;(ScriptToken\[\] tokens, Transaction transaction, ISignAlgorithm algorithm)  
  
  2.  {  
  
  3.      var ret = Evaluate(tokens, transaction, algorithm);  
  
  4.      **if** (**typeof**(T) == **typeof**(Boolean))  
  
  5.      {  
  
  6.          var s = ret.ToString().ToLower();  
  
  7.          **return** (T)(**object**)(s == "true");  
  
  8.      }  
  
  9.    
  
  10.     **return** (T)Convert.ChangeType(ret, **typeof**(T));  
  
  11. }  
  
  ----------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\Evaluator.cs

其中，

第3行，

  -----------------------------------------------------------------------------------------------------------------------------
  1.  **public** **static** **object** Evaluate(ScriptToken\[\] tokens, Transaction transaction, ISignAlgorithm algorithm)  
  
  2.  {  
  
  3.      var stack = **new** Stack&lt;ScriptToken&gt;();  
  
  4.    
  
  5.      **foreach** (var token **in** tokens)  
  
  6.      {  
  
  7.          **if** (!token.IsOpCode)  
  
  8.          {  
  
  9.              stack.Push(token);  
  
  10.             **continue**;  
  
  11.         }  
  
  12.   
  
  13.         **switch** (token.OpCode)  
  
  14.         {  
  
  15.             **case** OpCode.CheckSignature:  
  
  16.                 {  
  
  17.                     **if** (!stack.CanPop()) **return** **false**;  
  
  18.                     var pubKey = PublicKey.ParseBase58(stack.Pop().GetValue());  
  
  19.                     **if** (!stack.CanPop()) **return** **false**;  
  
  20.                     var sig = Signature.ParseBase58(stack.Pop().GetValue());  
  
  21.                     var ret = algorithm.Verify(**new**\[\] { (**byte**\[\])transaction.GetLockHash() }, pubKey, sig);  
  
  22.                     stack.Push(ScriptToken.CreateToken(ret));  
  
  23.                     **break**;  
  
  24.                 }  
  
  25.             **default**:  
  
  26.                 **break**;  
  
  27.         }  
  
  28.     }  
  
  29.   
  
  30.     **if** (!stack.CanPop()) **return** **false**;  
  
  31.     **return** stack.Pop().GetValue();  
  
  32. }  
  
  -----------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\Evaluator.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **static** **bool** TryExecuteAsync(**this** WholeScripts scripts, Transaction trans, ISignAlgorithm signAlgorithm = **null**)  
  
  2.  {  
  
  3.      signAlgorithm = signAlgorithm ?? **new** ECDsaSignAlgorithm();  
  
  4.      var eval = Evaluator.Evaluate&lt;**bool**&gt;(scripts, trans, signAlgorithm);  
  
  5.      **return** eval;  
  
  6.  }  
  
  -------------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\TokenScriptExtension.cs

其中，

第3行，

  --------------------------------------------------------------------------------------
  1.  **public** **static** **bool** CanPop(**this** Stack&lt;ScriptToken&gt; stack)  
  
  2.  {  
  
  3.      **return** stack.Count &gt; 0;  
  
  4.  }  
  
  --------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\TokenScriptExtension.cs

其中，

第3行，

### 智能合约

#### 交易结构

#### 智能合约

  --------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **static** UnlockScripts ProduceSingleUnlockScript(**this** Signature sig) =&gt; (UnlockScripts)**new**\[\] {  
  
  2.      ScriptToken.CreateToken(sig.ToBase58()),  
  
  3.  };  
  
  --------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\TokenScriptExtension.cs

其中，

第3行，

  -----------------------------------------------------------------------------------------------------------------------------
  1.  **public** **static** LockScripts ProduceSingleLockScript(**this** PublicKey pubKey) =&gt; (LockScripts)**new**\[\] {  
  
  2.      ScriptToken.CreateToken(pubKey.ToBase58()),  
  
  3.      ScriptToken.CreateToken(OpCode.CheckSignature),  
  
  4.  };  
  
  -----------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\TokenScriptExtension.cs

其中，

第3行，

#### 验证交易

  -----------------------------------------------------------------------------------------------------------
  1.  **public** **static** **bool** CanUnlock(**this** Transaction tran, TxInput input, TxOutput output)  
  
  2.  {  
  
  3.      **try**  
  
  4.      {  
  
  5.          var scripts = input.UnlockScripts + output.LockScripts;  
  
  6.          var result = scripts.TryExecuteAsync(tran);  
  
  7.          **if** (!result) **return** **false**;  
  
  8.      }  
  
  9.      **catch** (Exception)  
  
  10.     {  
  
  11.         **return** **false**;  
  
  12.     }  
  
  13.   
  
  14.     **return** **true**;  
  
  15. }  
  
  -----------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\SmartContracts\\TokenScriptExtension.cs

其中，

第3行，

  ----------------------------------------------------------------------------------------
  1.  **private** BlockHead GenerateBlock()  
  
  2.  {  
  
  3.      ...  
  
  4.      var minerTxOut = **new** TxOutput  
  
  5.      {  
  
  6.          LockScripts = **this**.MinerWallet.PublicKey.ProduceSingleLockScript(),  
  
  7.          Value = **this**.BlockChain.RewardOfBlock + fee  
  
  8.      };  
  
  9.      var minerTx = **new** Transaction { Outputs = **new**\[\] { minerTxOut }, };  
  
  10.     ...  
  
  11. }  
  
  ----------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\Engine.cs

其中，

第3行，

  ----------------------------------------------------------
  1.  **private** **bool** ValidateTx(Transaction tx)  
  
  2.  {  
  
  3.      ...  
  
  4.      **foreach** (var intx **in** tx.InputTxs)  
  
  5.      {  
  
  6.          ...  
  
  7.          **if** (!verifyTx.CanUnlock(intx, output))  
  
  8.              **return** **false**;  
  
  9.      }  
  
  10.     ...  
  
  11. }  
  
  ----------------------------------------------------------

参考代码：ClassicBlockChain\\Core\\Engine.cs

其中，

第3行，

#### 客户端适应

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------
  1.  **public** Transaction SendMoney(Engine engine, Transaction utxo, **int** index, IWallet receiver, **int** value, **int** fee = 0, **uint** lockTime = 0)  
  
  2.  {  
  
  3.      var total = utxo.Outputs\[index\].Value;  
  
  4.      var change = total - value - fee;  
  
  5.      var mainOutput = **new** TxOutput { LockScripts = receiver.PublicKey.ProduceSingleLockScript(), Value = value };  
  
  6.      var changeOutput = **new** TxOutput { LockScripts = **this**.PublicKey.ProduceSingleLockScript(), Value = change };  
  
  7.      **return** **this**.SendMoney(engine, lockTime, **new**\[\] { **new** Utxo(utxo, index) }, mainOutput, changeOutput);  
  
  8.  }  
  
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\BaseWallet.cs

其中，

第3行，

  ---------------------------------------------------------------------------------------------------------------------------
  1.  **public** Transaction SendMoney(Engine engine, **uint** lockTime, Utxo\[\] utxos, **params** TxOutput\[\] outputs)  
  
  2.  {  
  
  3.      var inputTxs = utxos  
  
  4.          .Select(\_ =&gt; **new** TxInput { PrevTxHash = \_.Tx.Hash, PrevTxIndex = \_.Index })  
  
  5.          .ToArray();  
  
  6.      var tx = **new** Transaction  
  
  7.      {  
  
  8.          InputTxs = inputTxs,  
  
  9.          Outputs = outputs,  
  
  10.         LockTime = lockTime,  
  
  11.     };  
  
  12.     var sigList = **new** Signature\[tx.InputTxs.Length\];  
  
  13.     **for** (**int** i = 0; i &lt; tx.InputTxs.Length; i++)  
  
  14.     {  
  
  15.         var utxoEnt = utxos\[i\];  
  
  16.         sigList\[i\] = **this**.signAlgo.Sign(  
  
  17.             **new**\[\] { (**byte**\[\])tx.GetLockHash() },  
  
  18.             **this**.FindPrivateKey(utxoEnt.Tx.Outputs\[utxoEnt.Index\].LockScripts));  
  
  19.     }  
  
  20.   
  
  21.     **for** (**int** i = 0; i &lt; tx.InputTxs.Length; i++)  
  
  22.     {  
  
  23.         tx.InputTxs\[i\].UnlockScripts = sigList\[i\].ProduceSingleUnlockScript();  
  
  24.     }  
  
  25.     engine.AttachTx(tx);  
  
  26.   
  
  27.     **return** tx;  
  
  28. }  
  
  ---------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\BaseWallet.cs

其中，

第3行，

  --------------------------------------------------------------------------------------
  1.  **protected** **abstract** PrivateKey FindPrivateKey(LockScripts lockScripts);  
  
  2.  **protected** **abstract** **bool** ContainPubKey(LockScripts lockScripts);  
  
  --------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\BaseWallet.cs

其中，

第3行，

  -------------------------------------------------------------------------------------------------------------------------------
  1.  **public** **class** DeterministicWallet : BaseWallet  
  
  2.  {  
  
  3.      **protected** **override** PrivateKey FindPrivateKey(LockScripts lockScripts)  
  
  4.      {  
  
  5.          var idx = **this**.usedPublicKeys.FindIndex(\_ =&gt; lockScripts.Contains(**new** ScriptToken(\_.ToBase58())));  
  
  6.          **if** (idx == -1)  
  
  7.              **throw** **new** KeyNotFoundException("cannot find corresponding public key");  
  
  8.          **return** **this**.usedPrivateKeys\[idx\];  
  
  9.      }  
  
  10.   
  
  11.     **protected** **override** **bool** ContainPubKey(LockScripts lockScripts)  
  
  12.     {  
  
  13.         **return** **this**.usedPublicKeys.Any(\_ =&gt; lockScripts.Contains(**new** ScriptToken(\_.ToBase58())));  
  
  14.     }  
  
  15. }  
  
  -------------------------------------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\DeterministicWallet.cs

其中，

第3行，

  ----------------------------------------------------------------------------------------------------
  1.  **public** **class** SimpleWallet : BaseWallet  
  
  2.  {  
  
  3.      **protected** **override** PrivateKey FindPrivateKey(LockScripts lockScripts)  
  
  4.      {  
  
  5.          **if** (!lockScripts.Contains(**new** ScriptToken(**this**.PublicKey.ToBase58())))  
  
  6.              **throw** **new** KeyNotFoundException("cannot find corresponding public key");  
  
  7.          **return** **this**.PrivateKey;  
  
  8.      }  
  
  9.    
  
  10.     **protected** **override** **bool** ContainPubKey(LockScripts lockScripts)  
  
  11.     {  
  
  12.         **return** lockScripts.Contains(**new** ScriptToken(**this**.PublicKey.ToBase58()));  
  
  13.     }  
  
  14. }  
  
  ----------------------------------------------------------------------------------------------------

参考代码：ClassicBlockChain\\Wallet\\SimpleWallet.cs

其中，

第3行，

### 本章练习

#### 基本练习一 锁定时间

  --
  --

参考代码：ClassicBlockChain\\SmartContracts\\.cs

其中，

第3行，

#### 基本练习二 智能合约

  --
  --

参考代码：ClassicBlockChain\\SmartContracts\\.cs

其中，

第3行，

高级主题
--------

### Bloom过滤器

### 攻击测试

### 挖矿

### 区块升级

### 地址

#### Base58

第二部分 当代的区块链
=====================

图灵完全的区块链
----------------

### 以太坊的历史及发展

#### 出现的动机

#### 以太坊历史上的失误

### 当代区块链系统概述

#### 

基本的区块链程序
----------------

### 定义区块结构

### 执行型交易结构

### 基数默克尔树（Patricia Merkle Trie）

### 区块的验证与创建

### 交易的确认

支持瘦客户端
------------

### 客户端

### 生成交易

### 交易的签名

用燃料的合约
------------

### 图灵完全的执行环境

### 燃料计算

### 定义执行状态

### 定义执行收据

### 

分布式网络
----------

### 定义世界状态

### 广播状态

### 共识达成

高级主题
--------

### 

第三部分 区块链数据库实现
=========================

数据库管理系统概述
------------------

### 数据库的发展

#### 关系型数据库

#### 键值对数据库

### 数据库管理系统

#### 查询处理

#### 事务处理

#### 主存及缓冲区

基本的区块链数据库
------------------

### 定义区块结构

### 定义事务结构

### 区块的验证与创建

### 事务的确认

支持瘦客户端
------------

### 客户端

### 生成事务

### 事务的签名

合约事务
--------

### 图灵完全却不用燃料

### 

分布式网络
----------

### 简单共识

### 天然的分布式数据库

查询处理
--------

### 索引结构

### 查询执行

### 

高级主题
--------

### 并发控制

### 

知识汇总
--------

### 应用场景

### 
